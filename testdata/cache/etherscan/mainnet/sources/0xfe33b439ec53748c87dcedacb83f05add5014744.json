{"expiry":6055833342,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/interfaces/IJBTokens.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool tokensWereClaimed, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external returns (IJBToken token);\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"},"src/structs/JBAccountingContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"},"src/interfaces/IJBPayHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"},"src/interfaces/IJBProjectUriRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"},"src/structs/JBCurrencyAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"},"src/libraries/JBRulesetMetadataResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function cashOutTaxRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Cash out tax rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function useTotalSurplusForCashOuts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 80) & 1 == 1;\n    }\n\n    function useDataHookForCashOut(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 82));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 242);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // cash out tax rate in bits 20-35 (16 bits).\n        // cash out tax rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.cashOutTaxRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow controller migration in bit 77.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 77;\n        // hold fees in bit 78.\n        if (rulesetMetadata.holdFees) packed |= 1 << 78;\n        // useTotalSurplusForCashOuts in bit 79.\n        if (rulesetMetadata.useTotalSurplusForCashOuts) packed |= 1 << 79;\n        // use pay data source in bit 80.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 80;\n        // use cash out data source in bit 81.\n        if (rulesetMetadata.useDataHookForCashOut) packed |= 1 << 81;\n        // data source address in bits 82-241.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 82;\n        // metadata in bits 242-255 (14 bits).\n        packed |= (uint256(rulesetMetadata.metadata) & 0x3FFF) << 242;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            cashOutTaxRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForCashOuts(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForCashOut(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"},"src/enums/JBApprovalStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"},"src/structs/JBFundAccessLimitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"},"src/structs/JBRulesetWithMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"},"src/structs/JBSplitHookContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"},"src/structs/JBTerminalConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"},"src/interfaces/IJBFundAccessLimits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/libraries/JBCashOuts.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./JBConstants.sol\";\n\n/// @notice Cash out calculations.\nlibrary JBCashOuts {\n    /// @notice Returns the amount of surplus terminal tokens which can be reclaimed based on the total surplus, the\n    /// number of tokens being cashed out, the total token supply, and the ruleset's cash out tax rate.\n    /// @param surplus The total amount of surplus terminal tokens.\n    /// @param cashOutCount The number of tokens being cashed out, as a fixed point number with 18 decimals.\n    /// @param totalSupply The total token supply, as a fixed point number with 18 decimals.\n    /// @param cashOutTaxRate The current ruleset's cash out tax rate.\n    /// @return reclaimableSurplus The amount of surplus tokens that can be reclaimed.\n    function cashOutFrom(\n        uint256 surplus,\n        uint256 cashOutCount,\n        uint256 totalSupply,\n        uint256 cashOutTaxRate\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // If the cash out tax rate is the max, no surplus can be reclaimed.\n        if (cashOutTaxRate == JBConstants.MAX_CASH_OUT_TAX_RATE) return 0;\n\n        // If the total supply is being cashed out, return the entire surplus.\n        if (cashOutCount >= totalSupply) return surplus;\n\n        // Get a reference to the linear proportion.\n        uint256 base = mulDiv(surplus, cashOutCount, totalSupply);\n\n        // These conditions are all part of the same curve.\n        // Edge conditions are separated to minimize the operations performed in those cases.\n        if (cashOutTaxRate == 0) {\n            return base;\n        }\n\n        return mulDiv(\n            base,\n            (JBConstants.MAX_CASH_OUT_TAX_RATE - cashOutTaxRate) + mulDiv(cashOutTaxRate, cashOutCount, totalSupply),\n            JBConstants.MAX_CASH_OUT_TAX_RATE\n        );\n    }\n}\n"},"src/interfaces/IJBSplits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"},"src/structs/JBBeforePayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedPercent The reserved percent of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedPercent;\n    bytes metadata;\n}\n"},"src/interfaces/IJBController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event DeployERC20(\n        uint256 indexed projectId, address indexed deployer, bytes32 salt, bytes32 saltHash, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n    function OMNICHAIN_RULESET_OPERATOR() external view returns (address);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"},"src/structs/JBTokenAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"},"src/structs/JBRuleset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"},"src/structs/JBBeforeCashOutRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon cash out.\n/// @custom:member terminal The terminal that is facilitating the cash out.\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project whose tokens are being cashed out.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of tokens being cashed out, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making cash outs.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset the cash out is being made during.\n/// @custom:member metadata Extra data provided by the casher.\nstruct JBBeforeCashOutRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 cashOutTaxRate;\n    bytes metadata;\n}\n"},"src/interfaces/IJBTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"},"src/structs/JBAfterCashOutRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project being cashed out from.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of project tokens being cashed out.\n/// @custom:member cashOutTaxRate The current ruleset's cash out tax rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the cash out hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the cash out hook.\n/// @custom:member cashOutMetadata Extra data specified by the account cashing out, which is sent to the cash out hook.\nstruct JBAfterCashOutRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 cashOutTaxRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes cashOutMetadata;\n}\n"},"src/structs/JBAfterPayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"},"node_modules/@prb/math/src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y÷1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*y÷denominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"},"src/libraries/JBConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"},"src/structs/JBPayHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/interfaces/IJBRulesets.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"},"src/interfaces/IJBProjects.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"},"src/JBTerminalStore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {JBFixedPointNumber} from \"./libraries/JBFixedPointNumber.sol\";\nimport {JBCashOuts} from \"./libraries/JBCashOuts.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBSurplus} from \"./libraries/JBSurplus.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBBeforePayRecordedContext} from \"./structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"./structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"./structs/JBCashOutHookSpecification.sol\";\nimport {JBCurrencyAmount} from \"./structs/JBCurrencyAmount.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice Manages all bookkeeping for inflows and outflows of funds from any terminal address.\n/// @dev This contract expects a project's controller to be an `IJBController`.\ncontract JBTerminalStore is IJBTerminalStore {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JBTerminalStore_InadequateControllerAllowance(uint256 amount, uint256 allowance);\n    error JBTerminalStore_InadequateControllerPayoutLimit(uint256 amount, uint256 limit);\n    error JBTerminalStore_InadequateTerminalStoreBalance(uint256 amount, uint256 balance);\n    error JBTerminalStore_InsufficientTokens(uint256 count, uint256 totalSupply);\n    error JBTerminalStore_InvalidAmountToForwardHook(uint256 amount, uint256 paidAmount);\n    error JBTerminalStore_RulesetNotFound();\n    error JBTerminalStore_RulesetPaymentPaused();\n    error JBTerminalStore_TerminalMigrationNotAllowed();\n\n    //*********************************************************************//\n    // -------------------------- internal constants --------------------- //\n    //*********************************************************************//\n\n    /// @notice Constrains `mulDiv` operations on fixed point numbers to a maximum number of decimal points of persisted\n    /// fidelity.\n    uint256 internal constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract that exposes price feeds.\n    IJBPrices public immutable override PRICES;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's balance of a specific token within a terminal.\n    /// @dev The balance is represented as a fixed point number with the same amount of decimals as its relative\n    /// terminal.\n    /// @custom:param terminal The terminal to get the project's balance within.\n    /// @custom:param projectId The ID of the project to get the balance of.\n    /// @custom:param token The token to get the balance for.\n    mapping(address terminal => mapping(uint256 projectId => mapping(address token => uint256))) public override\n        balanceOf;\n\n    /// @notice The currency-denominated amount of funds that a project has already paid out from its payout limit\n    /// during the current ruleset for each terminal, in terms of the payout limit's currency.\n    /// @dev Increases as projects pay out funds.\n    /// @dev The used payout limit is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the payout limit applies to.\n    /// @custom:param projectId The ID of the project to get the used payout limit of.\n    /// @custom:param token The token the payout limit applies to in the terminal.\n    /// @custom:param rulesetCycleNumber The cycle number of the ruleset the payout limit was used during.\n    /// @custom:param currency The currency the payout limit is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(\n                        address token => mapping(uint256 rulesetCycleNumber => mapping(uint256 currency => uint256))\n                    )\n            )\n    ) public override usedPayoutLimitOf;\n\n    /// @notice The currency-denominated amounts of funds that a project has used from its surplus allowance during the\n    /// current ruleset for each terminal, in terms of the surplus allowance's currency.\n    /// @dev Increases as projects use their allowance.\n    /// @dev The used surplus allowance is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the surplus allowance applies to.\n    /// @custom:param projectId The ID of the project to get the used surplus allowance of.\n    /// @custom:param token The token the surplus allowance applies to in the terminal.\n    /// @custom:param rulesetId The ID of the ruleset the surplus allowance was used during.\n    /// @custom:param currency The currency the surplus allowance is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(address token => mapping(uint256 rulesetId => mapping(uint256 currency => uint256)))\n            )\n    ) public override usedSurplusAllowanceOf;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param prices A contract that exposes price feeds.\n    /// @param rulesets A contract storing and managing project rulesets.\n    constructor(IJBDirectory directory, IJBPrices prices, IJBRulesets rulesets) {\n        DIRECTORY = directory;\n        PRICES = prices;\n        RULESETS = rulesets;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the number of surplus terminal tokens that would be reclaimed by cashing out a given project's\n    /// tokens based on its current ruleset and the given total project token supply and total terminal token surplus.\n    /// @param projectId The ID of the project whose project tokens would be cashed out.\n    /// @param cashOutCount The number of project tokens that would be cashed out, as a fixed point number with 18\n    /// decimals.\n    /// @param totalSupply The total project token supply, as a fixed point number with 18 decimals.\n    /// @param surplus The total terminal token surplus amount, as a fixed point number.\n    /// @return The number of surplus terminal tokens that would be reclaimed, as a fixed point number with the same\n    /// number of decimals as the provided `surplus`.\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 cashOutCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // If there's no surplus, nothing can be reclaimed.\n        if (surplus == 0) return 0;\n\n        // Can't cash out more tokens than are in the total supply.\n        if (cashOutCount > totalSupply) return 0;\n\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Return the amount of surplus terminal tokens that would be reclaimed.\n        return JBCashOuts.cashOutFrom({\n            surplus: surplus,\n            cashOutCount: cashOutCount,\n            totalSupply: totalSupply,\n            cashOutTaxRate: ruleset.cashOutTaxRate()\n        });\n    }\n\n    /// @notice Returns the number of surplus terminal tokens that would be reclaimed from a terminal by cashing out a\n    /// given number of tokens, based on the total token supply and total surplus.\n    /// @dev The returned amount in terms of the specified `terminal`'s base currency.\n    /// @dev The returned amount is represented as a fixed point number with the same amount of decimals as the\n    /// specified terminal.\n    /// @param projectId The ID of the project whose tokens would be cashed out.\n    /// @param cashOutCount The number of tokens that would be cashed out, as a fixed point number with 18 decimals.\n    /// @param terminals The terminals that would be cashed out from. If this is an empty array, surplus within all\n    /// the project's terminals are considered.\n    /// @param accountingContexts The accounting contexts of the surplus terminal tokens that would be reclaimed. Pass\n    /// an empty array to use all of the project's accounting contexts.\n    /// @param decimals The number of decimals to include in the resulting fixed point number.\n    /// @param currency The currency that the resulting number will be in terms of.\n    /// @return The amount of surplus terminal tokens that would be reclaimed by cashing out `cashOutCount`\n    /// tokens.\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 cashOutCount,\n        IJBTerminal[] calldata terminals,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // If a terminal wasn't provided, use the total surplus across all terminals. Otherwise,\n        // get the `terminal`'s surplus.\n        uint256 currentSurplus = JBSurplus.currentSurplusOf({\n            projectId: projectId,\n            terminals: terminals.length != 0 ? terminals : DIRECTORY.terminalsOf(projectId),\n            accountingContexts: accountingContexts,\n            decimals: decimals,\n            currency: currency\n        });\n\n        // If there's no surplus, nothing can be reclaimed.\n        if (currentSurplus == 0) return 0;\n\n        // Get the project token's total supply.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't cash out more tokens than are in the total supply.\n        if (cashOutCount > totalSupply) return 0;\n\n        // Return the amount of surplus terminal tokens that would be reclaimed.\n        return JBCashOuts.cashOutFrom({\n            surplus: currentSurplus,\n            cashOutCount: cashOutCount,\n            totalSupply: totalSupply,\n            cashOutTaxRate: ruleset.cashOutTaxRate()\n        });\n    }\n\n    /// @notice Gets the current surplus amount in a terminal for a specified project.\n    /// @dev The surplus is the amount of funds a project has in a terminal in excess of its payout limit.\n    /// @dev The surplus is represented as a fixed point number with the same amount of decimals as the specified\n    /// terminal.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param currency The currency the resulting amount should be in terms of.\n    /// @param decimals The number of decimals to expect in the resulting fixed point number.\n    /// @return The current surplus amount the project has in the specified terminal.\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return the surplus during the project's current ruleset.\n        return _surplusFrom({\n            terminal: terminal,\n            projectId: projectId,\n            accountingContexts: accountingContexts,\n            ruleset: RULESETS.currentOf(projectId),\n            targetDecimals: decimals,\n            targetCurrency: currency\n        });\n    }\n\n    /// @notice Gets the current surplus amount for a specified project across all terminals.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param decimals The number of decimals that the fixed point surplus should include.\n    /// @param currency The currency that the total surplus should be in terms of.\n    /// @return The current total surplus amount that the project has across all terminals.\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return JBSurplus.currentSurplusOf({\n            projectId: projectId,\n            terminals: DIRECTORY.terminalsOf(projectId),\n            accountingContexts: new JBAccountingContext[](0),\n            decimals: decimals,\n            currency: currency\n        });\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets a project's surplus amount in a terminal as measured by a given ruleset, across multiple accounting\n    /// contexts.\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// various payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param ruleset The ID of the ruleset to base the surplus on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _surplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the number of tokens being iterated on.\n        uint256 numberOfTokenAccountingContexts = accountingContexts.length;\n\n        // Add payout limits from each token.\n        for (uint256 i; i < numberOfTokenAccountingContexts; i++) {\n            uint256 tokenSurplus = _tokenSurplusFrom({\n                terminal: terminal,\n                projectId: projectId,\n                accountingContext: accountingContexts[i],\n                ruleset: ruleset,\n                targetDecimals: targetDecimals,\n                targetCurrency: targetCurrency\n            });\n            // Increment the surplus with any remaining balance.\n            if (tokenSurplus > 0) surplus += tokenSurplus;\n        }\n    }\n\n    /// @notice Get a project's surplus amount of a specific token in a given terminal as measured by a given ruleset\n    /// (one specific accounting context).\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// the payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus of.\n    /// @param accountingContext The accounting context of the token whose balance should contribute to the surplus\n    /// being measured.\n    /// @param ruleset The ID of the ruleset to base the surplus calculation on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _tokenSurplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext memory accountingContext,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the balance.\n        surplus = balanceOf[terminal][projectId][accountingContext.token];\n\n        // If needed, adjust the decimals of the fixed point number to have the correct decimals.\n        surplus = accountingContext.decimals == targetDecimals\n            ? surplus\n            : JBFixedPointNumber.adjustDecimals({\n                value: surplus,\n                decimals: accountingContext.decimals,\n                targetDecimals: targetDecimals\n            });\n\n        // Add up all the balances.\n        surplus = (surplus == 0 || accountingContext.currency == targetCurrency)\n            ? surplus\n            : mulDiv(\n                surplus,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                    // `_payoutLimitRemaining`'s fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: accountingContext.currency,\n                    unitCurrency: targetCurrency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Get a reference to the payout limit during the ruleset for the token.\n        JBCurrencyAmount[] memory payoutLimits = IJBController(address(DIRECTORY.controllerOf(projectId)))\n            .FUND_ACCESS_LIMITS().payoutLimitsOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: address(terminal),\n            token: accountingContext.token\n        });\n\n        // Keep a reference to the number of payout limits being iterated on.\n        uint256 numberOfPayoutLimits = payoutLimits.length;\n\n        // Loop through each payout limit to determine the cumulative normalized payout limit remaining.\n        for (uint256 i; i < numberOfPayoutLimits; i++) {\n            JBCurrencyAmount memory payoutLimit = payoutLimits[i];\n\n            // Set the payout limit value to the amount still available to pay out during the ruleset.\n            payoutLimit.amount = uint224(\n                payoutLimit.amount\n                    - usedPayoutLimitOf[terminal][projectId][accountingContext.token][ruleset.cycleNumber][payoutLimit\n                        .currency]\n            );\n\n            // Adjust the decimals of the fixed point number if needed to have the correct decimals.\n            payoutLimit.amount = accountingContext.decimals == targetDecimals\n                ? payoutLimit.amount\n                : uint224(\n                    JBFixedPointNumber.adjustDecimals({\n                        value: payoutLimit.amount,\n                        decimals: accountingContext.decimals,\n                        targetDecimals: targetDecimals\n                    })\n                );\n\n            // Convert the `payoutLimit`'s amount to be in terms of the provided currency.\n            payoutLimit.amount = payoutLimit.amount == 0 || payoutLimit.currency == targetCurrency\n                ? payoutLimit.amount\n                : uint224(\n                    mulDiv(\n                        payoutLimit.amount,\n                        10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                            // `payoutLimitRemaining`'s fidelity as possible when converting.\n                        PRICES.pricePerUnitOf({\n                            projectId: projectId,\n                            pricingCurrency: payoutLimit.currency,\n                            unitCurrency: targetCurrency,\n                            decimals: _MAX_FIXED_POINT_FIDELITY\n                        })\n                    )\n                );\n\n            // Decrement from the balance until it reaches zero.\n            if (surplus > payoutLimit.amount) {\n                surplus -= payoutLimit.amount;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Records funds being added to a project's balance.\n    /// @param projectId The ID of the project which funds are being added to the balance of.\n    /// @param token The token being added to the balance.\n    /// @param amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as\n    /// its relative terminal.\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external override {\n        // Increment the balance.\n        balanceOf[msg.sender][projectId][token] = balanceOf[msg.sender][projectId][token] + amount;\n    }\n\n    /// @notice Records a cash out from a project.\n    /// @dev Cashs out the project's tokens according to values provided by the ruleset's data hook. If the ruleset has\n    /// no\n    /// data hook, cashs out tokens along a cash out bonding curve that is a function of the number of tokens being\n    /// burned.\n    /// @param holder The account that is cashing out tokens.\n    /// @param projectId The ID of the project being cashing out from.\n    /// @param cashOutCount The number of project tokens to cash out, as a fixed point number with 18 decimals.\n    /// @param accountingContext The accounting context of the token being reclaimed by the cash out.\n    /// @param balanceAccountingContexts The accounting contexts of the tokens whose balances should contribute to the\n    /// surplus being reclaimed from.\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset during the cash out was made during, as a `JBRuleset` struct. This ruleset will\n    /// have a cash out tax rate provided by the cash out hook if applicable.\n    /// @return reclaimAmount The amount of tokens reclaimed from the terminal, as a fixed point number with 18\n    /// decimals.\n    /// @return cashOutTaxRate The cash out tax rate influencing the reclaim amount.\n    /// @return hookSpecifications A list of cash out hooks, including data and amounts to send to them. The terminal\n    /// should fulfill these specifications.\n    function recordCashOutFor(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes memory metadata\n    )\n        external\n        override\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 cashOutTaxRate,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        )\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // Use the local surplus if the ruleset specifies that it should be used. Otherwise, use the project's total\n        // surplus across all of its terminals.\n        uint256 currentSurplus = ruleset.useTotalSurplusForCashOuts()\n            ? JBSurplus.currentSurplusOf({\n                projectId: projectId,\n                terminals: DIRECTORY.terminalsOf(projectId),\n                accountingContexts: new JBAccountingContext[](0),\n                decimals: accountingContext.decimals,\n                currency: accountingContext.currency\n            })\n            : _surplusFrom({\n                terminal: msg.sender,\n                projectId: projectId,\n                accountingContexts: balanceAccountingContexts,\n                ruleset: ruleset,\n                targetDecimals: accountingContext.decimals,\n                targetCurrency: accountingContext.currency\n            });\n\n        // Get the total number of outstanding project tokens.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't cash out more tokens than are in the supply.\n        if (cashOutCount > totalSupply) revert JBTerminalStore_InsufficientTokens(cashOutCount, totalSupply);\n\n        // If the ruleset has a data hook which is enabled for cash outs, use it to derive a claim amount and memo.\n        if (ruleset.useDataHookForCashOut() && ruleset.dataHook() != address(0)) {\n            // Create the cash out context that'll be sent to the data hook.\n            JBBeforeCashOutRecordedContext memory context = JBBeforeCashOutRecordedContext({\n                terminal: msg.sender,\n                holder: holder,\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                cashOutCount: cashOutCount,\n                totalSupply: totalSupply,\n                surplus: JBTokenAmount({\n                    token: accountingContext.token,\n                    value: currentSurplus,\n                    decimals: accountingContext.decimals,\n                    currency: accountingContext.currency\n                }),\n                useTotalSurplus: ruleset.useTotalSurplusForCashOuts(),\n                cashOutTaxRate: ruleset.cashOutTaxRate(),\n                metadata: metadata\n            });\n\n            (cashOutTaxRate, cashOutCount, totalSupply, hookSpecifications) =\n                IJBRulesetDataHook(ruleset.dataHook()).beforeCashOutRecordedWith(context);\n        } else {\n            cashOutTaxRate = ruleset.cashOutTaxRate();\n        }\n\n        if (currentSurplus != 0) {\n            // Calculate reclaim amount using the current surplus amount.\n            reclaimAmount = JBCashOuts.cashOutFrom({\n                surplus: currentSurplus,\n                cashOutCount: cashOutCount,\n                totalSupply: totalSupply,\n                cashOutTaxRate: cashOutTaxRate\n            });\n        }\n\n        // Keep a reference to the amount that should be added to the project's balance.\n        uint256 balanceDiff = reclaimAmount;\n\n        // Ensure that the specifications have valid amounts.\n        if (hookSpecifications.length != 0) {\n            // Keep a reference to the number of cash out hooks specified.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Loop through each specification.\n            for (uint256 i; i < numberOfSpecifications; i++) {\n                // Get a reference to the specification's amount.\n                uint256 specificationAmount = hookSpecifications[i].amount;\n\n                // Ensure the amount is non-zero.\n                if (specificationAmount != 0) {\n                    // Increment the total amount being subtracted from the balance.\n                    balanceDiff += specificationAmount;\n                }\n            }\n        }\n\n        // The amount being reclaimed must be within the project's balance.\n        if (balanceDiff > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert JBTerminalStore_InadequateTerminalStoreBalance(\n                balanceDiff, balanceOf[msg.sender][projectId][accountingContext.token]\n            );\n        }\n\n        // Remove the reclaimed funds from the project's balance.\n        if (balanceDiff != 0) {\n            unchecked {\n                balanceOf[msg.sender][projectId][accountingContext.token] =\n                    balanceOf[msg.sender][projectId][accountingContext.token] - balanceDiff;\n            }\n        }\n    }\n\n    /// @notice Records a payment to a project.\n    /// @dev Mints the project's tokens according to values provided by the ruleset's data hook. If the ruleset has no\n    /// data hook, mints tokens in proportion with the amount paid.\n    /// @param payer The address that made the payment to the terminal.\n    /// @param amount The amount of tokens being paid. Includes the token being paid, their value, the number of\n    /// decimals included, and the currency of the amount.\n    /// @param projectId The ID of the project being paid.\n    /// @param beneficiary The address that should be the beneficiary of anything the payment yields (including project\n    /// tokens minted by the payment).\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset the payment was made during, as a `JBRuleset` struct.\n    /// @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    /// @return hookSpecifications A list of pay hooks, including data and amounts to send to them. The terminal should\n    /// fulfill these specifications.\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount calldata amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        override\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // The project must have a ruleset.\n        if (ruleset.cycleNumber == 0) revert JBTerminalStore_RulesetNotFound();\n\n        // The ruleset must not have payments paused.\n        if (ruleset.pausePay()) revert JBTerminalStore_RulesetPaymentPaused();\n\n        // The weight according to which new tokens are to be minted, as a fixed point number with 18 decimals.\n        uint256 weight;\n\n        // If the ruleset has a data hook enabled for payments, use it to derive a weight and memo.\n        if (ruleset.useDataHookForPay() && ruleset.dataHook() != address(0)) {\n            // Create the pay context that'll be sent to the data hook.\n            JBBeforePayRecordedContext memory context = JBBeforePayRecordedContext({\n                terminal: msg.sender,\n                payer: payer,\n                amount: amount,\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                beneficiary: beneficiary,\n                weight: ruleset.weight,\n                reservedPercent: ruleset.reservedPercent(),\n                metadata: metadata\n            });\n\n            (weight, hookSpecifications) = IJBRulesetDataHook(ruleset.dataHook()).beforePayRecordedWith(context);\n        }\n        // Otherwise use the ruleset's weight\n        else {\n            weight = ruleset.weight;\n        }\n\n        // Keep a reference to the amount that should be added to the project's balance.\n        uint256 balanceDiff = amount.value;\n\n        // Scoped section preventing stack too deep.\n        {\n            // Keep a reference to the number of hook specifications.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Ensure that the specifications have valid amounts.\n            for (uint256 i; i < numberOfSpecifications; i++) {\n                // Get a reference to the specification's amount.\n                uint256 specifiedAmount = hookSpecifications[i].amount;\n\n                // Ensure the amount is non-zero.\n                if (specifiedAmount != 0) {\n                    // Can't send more to hook than was paid.\n                    if (specifiedAmount > balanceDiff) {\n                        revert JBTerminalStore_InvalidAmountToForwardHook(specifiedAmount, balanceDiff);\n                    }\n\n                    // Decrement the total amount being added to the local balance.\n                    balanceDiff -= specifiedAmount;\n                }\n            }\n        }\n\n        // If there's no amount being recorded, there's nothing left to do.\n        if (amount.value == 0) return (ruleset, 0, hookSpecifications);\n\n        // Add the correct balance difference to the token balance of the project.\n        if (balanceDiff != 0) {\n            balanceOf[msg.sender][projectId][amount.token] =\n                balanceOf[msg.sender][projectId][amount.token] + balanceDiff;\n        }\n\n        // If there's no weight, the token count must be 0, so there's nothing left to do.\n        if (weight == 0) return (ruleset, 0, hookSpecifications);\n\n        // If the terminal should base its weight on a currency other than the terminal's currency, determine the\n        // factor. The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the\n        // same\n        // number of decimals as the `amount`.\n        uint256 weightRatio = amount.currency == ruleset.baseCurrency()\n            ? 10 ** amount.decimals\n            : PRICES.pricePerUnitOf({\n                projectId: projectId,\n                pricingCurrency: amount.currency,\n                unitCurrency: ruleset.baseCurrency(),\n                decimals: amount.decimals\n            });\n\n        // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n        tokenCount = mulDiv(amount.value, weight, weightRatio);\n    }\n\n    /// @notice Records a payout from a project.\n    /// @param projectId The ID of the project that is paying out funds.\n    /// @param accountingContext The context of the token being paid out.\n    /// @param amount The amount to pay out (use from the payout limit), as a fixed point number.\n    /// @param currency The currency of the `amount`. This must match the project's current ruleset's currency.\n    /// @return ruleset The ruleset the payout was made during, as a `JBRuleset` struct.\n    /// @return amountPaidOut The amount of terminal tokens paid out, as a fixed point number with the same amount of\n    /// decimals as its relative terminal.\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Convert the amount to the balance's currency.\n        amountPaidOut = (currency == accountingContext.currency)\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `_amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // The amount being paid out must be available.\n        if (amountPaidOut > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert JBTerminalStore_InadequateTerminalStoreBalance(\n                amountPaidOut, balanceOf[msg.sender][projectId][accountingContext.token]\n            );\n        }\n\n        // Removed the paid out funds from the project's token balance.\n        unchecked {\n            balanceOf[msg.sender][projectId][accountingContext.token] =\n                balanceOf[msg.sender][projectId][accountingContext.token] - amountPaidOut;\n        }\n\n        // The new total amount which has been paid out during this ruleset.\n        uint256 newUsedPayoutLimitOf =\n            usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] + amount;\n\n        // Store the new amount.\n        usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] =\n            newUsedPayoutLimitOf;\n\n        // Amount must be within what is still available to pay out.\n        uint256 payoutLimit = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .payoutLimitOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the payout limit.\n        if (newUsedPayoutLimitOf > payoutLimit || payoutLimit == 0) {\n            revert JBTerminalStore_InadequateControllerPayoutLimit(newUsedPayoutLimitOf, payoutLimit);\n        }\n    }\n\n    /// @notice Records the migration of funds from this store.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The token being migrated.\n    /// @return balance The project's current balance (which is being migrated), as a fixed point number with the same\n    /// amount of decimals as its relative terminal.\n    function recordTerminalMigration(uint256 projectId, address token) external override returns (uint256 balance) {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Terminal migration must be allowed.\n        if (!ruleset.allowTerminalMigration()) {\n            revert JBTerminalStore_TerminalMigrationNotAllowed();\n        }\n\n        // Return the current balance, which is the amount being migrated.\n        balance = balanceOf[msg.sender][projectId][token];\n\n        // Set the balance to 0.\n        balanceOf[msg.sender][projectId][token] = 0;\n    }\n\n    /// @notice Records a use of a project's surplus allowance.\n    /// @dev When surplus allowance is \"used\", it is taken out of the project's surplus within a terminal.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param accountingContext The accounting context of the token whose balances should contribute to the surplus\n    /// allowance being reclaimed from.\n    /// @param amount The amount to use from the surplus allowance, as a fixed point number.\n    /// @param currency The currency of the `amount`. Must match the currency of the surplus allowance.\n    /// @return ruleset The ruleset during the surplus allowance is being used during, as a `JBRuleset` struct.\n    /// @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals\n    /// as its relative terminal.\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        returns (JBRuleset memory ruleset, uint256 usedAmount)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Convert the amount to this store's terminal's token.\n        usedAmount = currency == accountingContext.currency\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Set the token being used as the only one to look for surplus within.\n        JBAccountingContext[] memory accountingContexts = new JBAccountingContext[](1);\n        accountingContexts[0] = accountingContext;\n\n        uint256 surplus = _surplusFrom({\n            terminal: msg.sender,\n            projectId: projectId,\n            accountingContexts: accountingContexts,\n            ruleset: ruleset,\n            targetDecimals: accountingContext.decimals,\n            targetCurrency: accountingContext.currency\n        });\n\n        // The amount being used must be available in the surplus.\n        if (usedAmount > surplus) revert JBTerminalStore_InadequateTerminalStoreBalance(usedAmount, surplus);\n\n        // Update the project's balance.\n        balanceOf[msg.sender][projectId][accountingContext.token] =\n            balanceOf[msg.sender][projectId][accountingContext.token] - usedAmount;\n\n        // Get a reference to the new used surplus allowance for this ruleset ID.\n        uint256 newUsedSurplusAllowanceOf =\n            usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] + amount;\n\n        // Store the incremented value.\n        usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] =\n            newUsedSurplusAllowanceOf;\n\n        // There must be sufficient surplus allowance available.\n        uint256 surplusAllowance = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .surplusAllowanceOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the allowance.\n        if (newUsedSurplusAllowanceOf > surplusAllowance || surplusAllowance == 0) {\n            revert JBTerminalStore_InadequateControllerAllowance(newUsedSurplusAllowanceOf, surplusAllowance);\n        }\n    }\n}\n"},"src/interfaces/IJBPriceFeed.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"},"src/interfaces/IJBSplitHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"},"src/interfaces/IJBToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function canBeAddedTo(uint256 projectId) external view returns (bool);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"},"src/interfaces/IJBTokenUriResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"},"src/structs/JBRulesetConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a cut `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"},"src/libraries/JBFixedPointNumber.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary JBFixedPointNumber {\n    function adjustDecimals(uint256 value, uint256 decimals, uint256 targetDecimals) internal pure returns (uint256) {\n        // If decimals need adjusting, multiply or divide the price by the decimal adjuster to get the normalized\n        // result.\n        if (targetDecimals == decimals) return value;\n        else if (targetDecimals > decimals) return value * 10 ** (targetDecimals - decimals);\n        else return value / 10 ** (decimals - targetDecimals);\n    }\n}\n"},"src/structs/JBCashOutHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutHook} from \"../interfaces/IJBCashOutHook.sol\";\n\n/// @notice A cash out hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The cash out hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBCashOutHookSpecification {\n    IJBCashOutHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/interfaces/IJBDirectory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"},"src/structs/JBSplitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"},"src/interfaces/IJBRulesetApprovalHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) external view returns (JBApprovalStatus);\n}\n"},"src/libraries/JBSurplus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IJBTerminal} from \"../interfaces/IJBTerminal.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\n\n/// @notice Surplus calculations.\nlibrary JBSurplus {\n    /// @notice Gets the total current surplus amount across all of a project's terminals.\n    /// @dev This amount changes as the value of the balances changes in relation to the currency being used to measure\n    /// the project's payout limits.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param terminals The terminals to look for surplus within.\n    /// @param accountingContexts The accounting contexts to use to calculate the surplus.\n    /// @param decimals The number of decimals that the fixed point surplus result should include.\n    /// @param currency The currency that the surplus result should be in terms of.\n    /// @return surplus The total surplus of a project's funds in terms of `currency`, as a fixed point number with the\n    /// specified number of decimals.\n    function currentSurplusOf(\n        uint256 projectId,\n        IJBTerminal[] memory terminals,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the number of termainls.\n        uint256 numberOfTerminals = terminals.length;\n\n        // Add the current surplus for each terminal.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            surplus += terminals[i].currentSurplusOf({\n                projectId: projectId,\n                accountingContexts: accountingContexts,\n                decimals: decimals,\n                currency: currency\n            });\n        }\n    }\n}\n"},"src/interfaces/IJBRulesetDataHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"./../structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"./../structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/cashout functionality by overriding the weight or memo. They can\n/// also specify pay/cashout hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForCashOut` enabled, its `dataHook` is called by\n/// the terminal upon payments/cashouts (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param ruleset The ruleset to check the token minting permission of.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(\n        uint256 projectId,\n        JBRuleset memory ruleset,\n        address addr\n    )\n        external\n        view\n        returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a cash out is recorded in the terminal store. This data is provided to the\n    /// terminal's `cashOutTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `cashOutTokensOf(...)` function as a\n    /// `JBBeforeCashOutRecordedContext` struct.\n    /// @return cashOutTaxRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return cashOutCount The amount of tokens that should be considered cashed out.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to cash out hooks instead of returning to the\n    /// beneficiary.\n    function beforeCashOutRecordedWith(JBBeforeCashOutRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 cashOutTaxRate,\n            uint256 cashOutCount,\n            uint256 totalSupply,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        );\n}\n"},"src/interfaces/IJBTerminalStore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBAccountingContext} from \"./../structs/JBAccountingContext.sol\";\nimport {JBCashOutHookSpecification} from \"./../structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./../structs/JBTokenAmount.sol\";\n\ninterface IJBTerminalStore {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PRICES() external view returns (IJBPrices);\n    function RULESETS() external view returns (IJBRulesets);\n\n    function balanceOf(address terminal, uint256 projectId, address token) external view returns (uint256);\n    function usedPayoutLimitOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetCycleNumber,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function usedSurplusAllowanceOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 cashOutCount,\n        IJBTerminal[] calldata terminals,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external;\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount memory amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications);\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut);\n    function recordCashOutFor(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes calldata metadata\n    )\n        external\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 cashOutTaxRate,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        );\n    function recordTerminalMigration(uint256 projectId, address token) external returns (uint256 balance);\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 usedAmount);\n}\n"},"src/structs/JBSplit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    uint32 percent;\n    uint64 projectId;\n    address payable beneficiary;\n    bool preferAddToBalance;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"},"src/structs/JBRulesetMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOuts A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForCashOut A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, only the 14 least significant bits can be used, the 2 most\n/// significant bits are disregarded.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForPay;\n    bool useDataHookForCashOut;\n    address dataHook;\n    uint16 metadata;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"src/interfaces/IJBCashOutHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterCashOutRecordedContext} from \"./../structs/JBAfterCashOutRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `cashOutTokensOf(...)` logic completes (if passed by the ruleset's data\n/// hook).\ninterface IJBCashOutHook is IERC165 {\n    /// @notice This function is called by the terminal's `cashOutTokensOf(...)` function after the cash out has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterCashOutRecordedContext` struct.\n    function afterCashOutRecordedWith(JBAfterCashOutRecordedContext calldata context) external payable;\n}\n"},"src/interfaces/IJBDirectoryAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"},"src/interfaces/IJBPrices.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"}},"settings":{"evmVersion":"paris","metadata":{"appendCBOR":true,"bytecodeHash":"ipfs","useLiteralContent":false},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/","@arbitrum/=node_modules/@arbitrum/","@bananapus/=node_modules/@bananapus/","@chainlink/=node_modules/@chainlink/","@eth-optimism/=node_modules/@eth-optimism/","@offchainlabs/=node_modules/@offchainlabs/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@scroll-tech/=node_modules/@scroll-tech/","@uniswap/=node_modules/@uniswap/","@zksync/=node_modules/@zksync/","forge-std/=lib/forge-std/src/","hardhat/=node_modules/hardhat/","solmate/=node_modules/solmate/","sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"],"viaIR":false}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"directory\",\"type\":\"address\"},{\"internalType\":\"contract IJBPrices\",\"name\":\"prices\",\"type\":\"address\"},{\"internalType\":\"contract IJBRulesets\",\"name\":\"rulesets\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"JBTerminalStore_InadequateControllerAllowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBTerminalStore_InadequateControllerPayoutLimit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"JBTerminalStore_InadequateTerminalStoreBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"JBTerminalStore_InsufficientTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"JBTerminalStore_InvalidAmountToForwardHook\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBTerminalStore_RulesetNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBTerminalStore_RulesetPaymentPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBTerminalStore_TerminalMigrationNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DIRECTORY\",\"outputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICES\",\"outputs\":[{\"internalType\":\"contract IJBPrices\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RULESETS\",\"outputs\":[{\"internalType\":\"contract IJBRulesets\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"}],\"name\":\"currentReclaimableSurplusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"internalType\":\"contract IJBTerminal[]\",\"name\":\"terminals\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContexts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"currentReclaimableSurplusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContexts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"currentSurplusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"currentTotalSurplusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recordAddedBalanceFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext\",\"name\":\"accountingContext\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"balanceAccountingContexts\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"recordCashOutFor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"reclaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutTaxRate\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IJBCashOutHook\",\"name\":\"hook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct JBCashOutHookSpecification[]\",\"name\":\"hookSpecifications\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct JBTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"recordPaymentFrom\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IJBPayHook\",\"name\":\"hook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct JBPayHookSpecification[]\",\"name\":\"hookSpecifications\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext\",\"name\":\"accountingContext\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"recordPayoutFor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amountPaidOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recordTerminalMigration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext\",\"name\":\"accountingContext\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"recordUsedAllowanceOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"usedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"usedPayoutLimitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"usedSurplusAllowanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"JBTerminalStore","CompilerVersion":"v0.8.23+commit.f704f362","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000000061e516886a0540f63157f112c0588ee0651dcf0000000000000000000000009b90e507cf6b7eb681a506b111f6f50245e614c40000000000000000000000006292281d69c3593fcf6ea074e5797341476ab428","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}