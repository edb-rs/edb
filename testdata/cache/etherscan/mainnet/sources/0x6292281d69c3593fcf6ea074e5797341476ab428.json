{"expiry":6055833342,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/interfaces/IJBControlled.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\n\ninterface IJBControlled {\n    function DIRECTORY() external view returns (IJBDirectory);\n}\n"},"src/JBRulesets.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBRulesetApprovalHook} from \"./interfaces/IJBRulesetApprovalHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetWeightCache} from \"./structs/JBRulesetWeightCache.sol\";\n\n/// @notice Manages rulesets and queuing.\n/// @dev Rulesets dictate how a project behaves for a period of time. To learn more about their functionality, see the\n/// `JBRuleset` data structure.\n/// @dev Throughout this contract, `rulesetId` is an identifier for each ruleset. The `rulesetId` is the unix timestamp\n/// when the ruleset was initialized.\n/// @dev `approvable` means a ruleset which may or may not be approved.\ncontract JBRulesets is JBControlled, IJBRulesets {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JBRulesets_InvalidWeightCutPercent(uint256 percent);\n    error JBRulesets_InvalidRulesetApprovalHook(IJBRulesetApprovalHook hook);\n    error JBRulesets_InvalidRulesetDuration(uint256 duration, uint256 limit);\n    error JBRulesets_InvalidRulesetEndTime(uint256 timestamp, uint256 limit);\n    error JBRulesets_InvalidWeight(uint256 weight, uint256 limit);\n\n    //*********************************************************************//\n    // ------------------------- internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice The number of weight cut percent multiples before a cached value is sought.\n    uint256 internal constant _WEIGHT_CUT_MULTIPLE_CACHE_LOOKUP_THRESHOLD = 1000;\n\n    /// @notice The maximum number of weight cut percent multiples that can be cached at a time.\n    uint256 internal constant _MAX_WEIGHT_CUT_MULTIPLE_CACHE_THRESHOLD = 50_000;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the ruleset with the latest start time for a specific project, whether the ruleset has been\n    /// approved or not.\n    /// @dev If a project has multiple rulesets queued, the `latestRulesetIdOf` will be the last one. This is the\n    /// \"changeable\" cycle.\n    /// @custom:param projectId The ID of the project to get the latest ruleset ID of.\n    /// @return latestRulesetIdOf The `rulesetId` of the project's latest ruleset.\n    mapping(uint256 projectId => uint256) public override latestRulesetIdOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice The metadata for each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get metadata of.\n    /// @custom:param rulesetId The ID of the ruleset to get metadata of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _metadataOf;\n\n    /// @notice The mechanism-added properties to manage and schedule each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the intrinsic properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the intrinsic properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedIntrinsicPropertiesOf;\n\n    /// @notice The user-defined properties of each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the user-defined properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the user-defined properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedUserPropertiesOf;\n\n    /// @notice Cached weight values to derive rulesets from.\n    /// @custom:param projectId The ID of the project to which the cache applies.\n    /// @custom:param rulesetId The ID of the ruleset to which the cache applies.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => JBRulesetWeightCache)) internal _weightCacheOf;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get an array of a project's rulesets up to a maximum array size, sorted from latest to earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If 0 is\n    /// passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The rulesets as an array of `JBRuleset` structs.\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRuleset[] memory rulesets)\n    {\n        // If no starting ID was provided, set it to the latest ruleset's ID.\n        if (startingId == 0) startingId = latestRulesetIdOf[projectId];\n\n        // Keep a reference to the number of rulesets being returned.\n        uint256 count = 0;\n\n        // Keep a reference to the starting ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, startingId);\n\n        // First, count the number of rulesets to include in the result by iterating backwards from the starting\n        // ruleset.\n        while (ruleset.id != 0 && count < size) {\n            // Increment the counter.\n            count++;\n\n            // Iterate to the ruleset it was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n\n        // Keep a reference to the array of rulesets that'll be populated.\n        rulesets = new JBRuleset[](count);\n\n        // Return an empty array if there are no rulesets to return.\n        if (count == 0) {\n            return rulesets;\n        }\n\n        // Reset the ruleset being iterated on to the starting ruleset.\n        ruleset = _getStructFor(projectId, startingId);\n\n        // Set the counter.\n        uint256 i;\n\n        // Populate the array of rulesets to return.\n        while (i < count) {\n            // Add the ruleset to the array.\n            rulesets[i++] = ruleset;\n\n            // Get the ruleset it was based on if needed.\n            if (i != count) ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n    }\n\n    /// @notice The current approval status of a given project's latest ruleset.\n    /// @param projectId The ID of the project to check the approval status of.\n    /// @return The project's current approval status.\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBApprovalStatus)\n    {\n        // Get a reference to the latest ruleset ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        return _approvalStatusOf({projectId: projectId, ruleset: ruleset});\n    }\n\n    /// @notice The ruleset that is currently active for the specified project.\n    /// @dev If a current ruleset of the project is not found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The project's current ruleset.\n    function currentOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the currently approvable ruleset's ID.\n        uint256 rulesetId = _currentlyApprovableRulesetIdOf(projectId);\n\n        // If a currently approvable ruleset exists...\n        if (rulesetId != 0) {\n            // Resolve the struct for the currently approvable ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // Check to see if this ruleset's approval hook is approved if it exists.\n            // If so, return it.\n            // slither-disable-next-line incorrect-equality\n            if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n                return ruleset;\n            }\n\n            // If it hasn't been approved, set the ruleset configuration to be the configuration of the ruleset that\n            // it's based on,\n            // which carries the last approved configuration.\n            rulesetId = ruleset.basedOnId;\n\n            // Keep a reference to its ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n        } else {\n            // No upcoming ruleset found that is currently approvable,\n            // so use the latest ruleset ID.\n            rulesetId = latestRulesetIdOf[projectId];\n\n            // Get the struct for the latest ID.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // While the ruleset has a approval hook that isn't approved or if it hasn't yet started, get a reference to\n            // the ruleset that the latest is based on, which has the latest approved configuration.\n            while (\n                (approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.Empty)\n                    || block.timestamp < ruleset.start\n            ) {\n                rulesetId = ruleset.basedOnId;\n                ruleset = _getStructFor(projectId, rulesetId);\n                approvalStatus = _approvalStatusOf(projectId, ruleset);\n            }\n        }\n\n        // If the base has no duration, it's still the current one.\n        // slither-disable-next-line incorrect-equality\n        if (ruleset.duration == 0) return ruleset;\n\n        // Return a simulation of the current ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: true});\n    }\n\n    /// @notice Get the ruleset struct for a given `rulesetId` and `projectId`.\n    /// @param projectId The ID of the project to which the ruleset belongs.\n    /// @param rulesetId The ID of the ruleset to get the struct of.\n    /// @return ruleset The ruleset struct.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset)\n    {\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice The latest ruleset queued for a project. Returns the ruleset's struct and its current approval status.\n    /// @dev Returns struct and status for the ruleset initialized furthest in the future (at the end of the ruleset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest queued ruleset of.\n    /// @return ruleset The project's latest queued ruleset's struct.\n    /// @return approvalStatus The approval hook's status for the ruleset.\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus)\n    {\n        // Get a reference to the latest ruleset's ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // Resolve the approval status.\n        approvalStatus = _approvalStatusOf({projectId: projectId, ruleset: ruleset});\n    }\n\n    /// @notice The ruleset that's up next for a project.\n    /// @dev If an upcoming ruleset is not found for the project, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the upcoming ruleset of.\n    /// @return ruleset The struct for the project's upcoming ruleset.\n    function upcomingOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a latest ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the upcoming approvable ruleset's ID.\n        uint256 upcomingApprovableRulesetId = _upcomingApprovableRulesetIdOf(projectId);\n\n        // Keep a reference to its approval status.\n        JBApprovalStatus approvalStatus;\n\n        // If an upcoming approvable ruleset has been queued, and it's approval status is Approved or ApprovalExpected,\n        // return its ruleset struct\n        if (upcomingApprovableRulesetId != 0) {\n            ruleset = _getStructFor(projectId, upcomingApprovableRulesetId);\n\n            // Get a reference to the approval status.\n            approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // If the approval hook is empty, expects approval, or has approved the ruleset, return it.\n            if (\n                // slither-disable-next-line incorrect-equality\n                approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.ApprovalExpected\n                    || approvalStatus == JBApprovalStatus.Empty\n            ) return ruleset;\n\n            // Resolve the ruleset for the ruleset the upcoming approvable ruleset was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } else {\n            // Resolve the ruleset for the latest queued ruleset.\n            ruleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n            // If the latest ruleset starts in the future, it must start in the distant future\n            // Since its not the upcoming approvable ruleset. In this case, base the upcoming ruleset on the base\n            // ruleset.\n            while (ruleset.start > block.timestamp) {\n                ruleset = _getStructFor(projectId, ruleset.basedOnId);\n            }\n        }\n\n        // There's no queued if the current has a duration of 0.\n        // slither-disable-next-line incorrect-equality\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the approval status.\n        approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n        // Check to see if this ruleset's approval hook hasn't failed.\n        // If so, return a ruleset based on it.\n        // slither-disable-next-line incorrect-equality\n        if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n            return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n        }\n\n        // Get the ruleset of its base ruleset, which carries the last approved configuration.\n        ruleset = _getStructFor(projectId, ruleset.basedOnId);\n\n        // There's no queued if the base, which must still be the current, has a duration of 0.\n        // slither-disable-next-line incorrect-equality\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Return a simulated cycled ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n    }\n\n    //*********************************************************************//\n    // --------------------------- public views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The cycle number of the next ruleset given the specified ruleset.\n    /// @dev Each time a ruleset starts, whether it was queued or cycled over, the cycle number is incremented by 1.\n    /// @param baseRulesetCycleNumber The cycle number of the base ruleset.\n    /// @param baseRulesetStart The start time of the base ruleset.\n    /// @param baseRulesetDuration The duration of the base ruleset.\n    /// @param start The start time of the ruleset to derive a cycle number for.\n    /// @return The ruleset's cycle number.\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        // A subsequent ruleset to one with a duration of 0 should be the next number.\n        // slither-disable-next-line incorrect-equality\n        if (baseRulesetDuration == 0) {\n            return baseRulesetCycleNumber + 1;\n        }\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRulesetStart;\n\n        // Find the number of base rulesets that fit in the start distance.\n        return baseRulesetCycleNumber + (startDistance / baseRulesetDuration);\n    }\n\n    /// @notice The date that is the nearest multiple of the base ruleset's duration from the start of the next cycle.\n    /// @param baseRulesetStart The start time of the base ruleset.\n    /// @param baseRulesetDuration The duration of the base ruleset.\n    /// @param mustStartAtOrAfter The earliest time the next ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return start The next start time.\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        public\n        pure\n        returns (uint256 start)\n    {\n        // A subsequent ruleset to one with a duration of 0 should start as soon as possible.\n        // slither-disable-next-line incorrect-equality\n        if (baseRulesetDuration == 0) return mustStartAtOrAfter;\n\n        // The time when the ruleset immediately after the specified ruleset starts.\n        uint256 nextImmediateStart = baseRulesetStart + baseRulesetDuration;\n\n        // If the next immediate start is now or in the future, return it.\n        if (nextImmediateStart >= mustStartAtOrAfter) {\n            return nextImmediateStart;\n        }\n\n        // The amount of seconds since the `mustStartAtOrAfter` time which results in a start time that might satisfy\n        // the specified limits.\n        // slither-disable-next-line weak-prng\n        uint256 timeFromImmediateStartMultiple = (mustStartAtOrAfter - nextImmediateStart) % baseRulesetDuration;\n\n        // A reference to the first possible start timestamp.\n        start = mustStartAtOrAfter - timeFromImmediateStartMultiple;\n\n        // Add increments of duration as necessary to satisfy the threshold.\n        while (mustStartAtOrAfter > start) {\n            start += baseRulesetDuration;\n        }\n    }\n\n    /// @notice The accumulated weight change since the specified ruleset.\n    /// @param projectId The ID of the project to which the ruleset weights apply.\n    /// @param baseRulesetStart The start time of the base ruleset.\n    /// @param baseRulesetDuration The duration of the base ruleset.\n    /// @param baseRulesetWeight The weight of the base ruleset.\n    /// @param baseRulesetWeightCutPercent The weight cut percent of the base ruleset.\n    /// @param baseRulesetCacheId The ID of the ruleset to base the calculation on (the previous ruleset).\n    /// @param start The start time of the ruleset to derive a weight for.\n    /// @return weight The derived weight, as a fixed point number with 18 decimals.\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        public\n        view\n        returns (uint256 weight)\n    {\n        // A subsequent ruleset to one with a duration of 0 should have the next possible weight.\n        // slither-disable-next-line incorrect-equality\n        if (baseRulesetDuration == 0) {\n            return mulDiv(\n                baseRulesetWeight,\n                JBConstants.MAX_WEIGHT_CUT_PERCENT - baseRulesetWeightCutPercent,\n                JBConstants.MAX_WEIGHT_CUT_PERCENT\n            );\n        }\n\n        // The weight should be based off the base ruleset's weight.\n        weight = baseRulesetWeight;\n\n        // If the weight cut percent is 0, the weight doesn't change.\n        // slither-disable-next-line incorrect-equality\n        if (baseRulesetWeightCutPercent == 0) return weight;\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRulesetStart;\n\n        // Apply the base ruleset's weight cut percent for each ruleset that has passed.\n        uint256 weightCutMultiple;\n        unchecked {\n            weightCutMultiple = startDistance / baseRulesetDuration; // Non-null duration is excluded above\n        }\n\n        // Check the cache if needed.\n        if (baseRulesetCacheId > 0 && weightCutMultiple > _WEIGHT_CUT_MULTIPLE_CACHE_LOOKUP_THRESHOLD) {\n            // Get a cached weight for the rulesetId.\n            JBRulesetWeightCache memory cache = _weightCacheOf[projectId][baseRulesetCacheId];\n\n            // If a cached value is available, use it.\n            if (cache.weightCutMultiple > 0) {\n                // Set the starting weight to be the cached value.\n                weight = cache.weight;\n\n                // Set the weight cut multiple to be the difference between the cached value and the total weight cut\n                // multiple that should be applied.\n                weightCutMultiple -= cache.weightCutMultiple;\n            }\n        }\n\n        for (uint256 i; i < weightCutMultiple; i++) {\n            // The number of times to apply the weight cut percent.\n            // Base the new weight on the specified ruleset's weight.\n            weight = mulDiv(\n                weight,\n                JBConstants.MAX_WEIGHT_CUT_PERCENT - baseRulesetWeightCutPercent,\n                JBConstants.MAX_WEIGHT_CUT_PERCENT\n            );\n\n            // The calculation doesn't need to continue if the weight is 0.\n            if (weight == 0) break;\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice The approval status of a given ruleset for a given project ID.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param ruleset The ruleset to get the approval status of.\n    /// @return The approval status of the project.\n    function _approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) internal view returns (JBApprovalStatus) {\n        // If there is no ruleset ID to check the approval hook of, the approval hook is empty.\n        // slither-disable-next-line incorrect-equality\n        if (ruleset.basedOnId == 0) return JBApprovalStatus.Empty;\n\n        // Get the struct of the ruleset with the approval hook.\n        JBRuleset memory approvalHookRuleset = _getStructFor(projectId, ruleset.basedOnId);\n\n        // If there is no approval hook, it's considered empty.\n        if (approvalHookRuleset.approvalHook == IJBRulesetApprovalHook(address(0))) {\n            return JBApprovalStatus.Empty;\n        }\n\n        // Return the approval hook's approval status.\n        // slither-disable-next-line calls-loop\n        return approvalHookRuleset.approvalHook.approvalStatusOf(projectId, ruleset);\n    }\n\n    /// @notice The ID of the ruleset which has started and hasn't expired yet, whether or not it has been approved, for\n    /// a given project. If approved, this is the active ruleset.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a latest ruleset.\n    /// @param projectId The ID of the project to check for a currently approvable ruleset.\n    /// @return The ID of a currently approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _currentlyApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256) {\n        // Get a reference to the project's latest ruleset.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // Loop through all most recently queued rulesets until an approvable one is found, or we've proven one can't\n        // exist.\n        do {\n            // If the latest ruleset is expired, return an empty ruleset.\n            // A ruleset with a duration of 0 cannot expire.\n            if (ruleset.duration != 0 && block.timestamp >= ruleset.start + ruleset.duration) {\n                return 0;\n            }\n\n            // Return the ruleset's `rulesetId` if it has started.\n            if (block.timestamp >= ruleset.start) {\n                return ruleset.id;\n            }\n\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } while (ruleset.cycleNumber != 0);\n\n        return 0;\n    }\n\n    /// @notice Unpack a ruleset's packed stored values into an easy-to-work-with ruleset struct.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetId The ID of the ruleset to get the full struct for.\n    /// @return ruleset A ruleset struct.\n    function _getStructFor(uint256 projectId, uint256 rulesetId) internal view returns (JBRuleset memory ruleset) {\n        // Return an empty ruleset if the specified `rulesetId` is 0.\n        // slither-disable-next-line incorrect-equality\n        if (rulesetId == 0) return ruleset;\n\n        ruleset.id = uint48(rulesetId);\n\n        uint256 packedIntrinsicProperties = _packedIntrinsicPropertiesOf[projectId][rulesetId];\n\n        // `weight` in bits 0-111 bits.\n        ruleset.weight = uint112(packedIntrinsicProperties);\n        // `basedOnId` in bits 112-159 bits.\n        ruleset.basedOnId = uint48(packedIntrinsicProperties >> 112);\n        // `start` in bits 160-207 bits.\n        ruleset.start = uint48(packedIntrinsicProperties >> 160);\n        // `cycleNumber` in bits 208-255 bits.\n        ruleset.cycleNumber = uint48(packedIntrinsicProperties >> 208);\n\n        uint256 packedUserProperties = _packedUserPropertiesOf[projectId][rulesetId];\n\n        // approval hook in bits 0-159 bits.\n        ruleset.approvalHook = IJBRulesetApprovalHook(address(uint160(packedUserProperties)));\n        // `duration` in bits 160-191 bits.\n        ruleset.duration = uint32(packedUserProperties >> 160);\n        // weight cut percent in bits 192-223 bits.\n        ruleset.weightCutPercent = uint32(packedUserProperties >> 192);\n\n        ruleset.metadata = _metadataOf[projectId][rulesetId];\n    }\n\n    /// @notice A simulated view of the ruleset that would be created if the provided one cycled over (if the project\n    /// doesn't queue a new ruleset).\n    /// @dev Returns an empty ruleset if a ruleset can't be simulated based on the provided one.\n    /// @dev Assumes a simulated ruleset will never be based on a ruleset with a duration of 0.\n    /// @param projectId The ID of the project of the ruleset.\n    /// @param baseRuleset The ruleset that the simulated ruleset should be based on.\n    /// @param allowMidRuleset A flag indicating if the simulated ruleset is allowed to already be mid ruleset.\n    /// @return A simulated ruleset struct: the next ruleset by default. This will be overwritten if a new ruleset is\n    /// queued for the project.\n    function _simulateCycledRulesetBasedOn(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        bool allowMidRuleset\n    )\n        internal\n        view\n        returns (JBRuleset memory)\n    {\n        // Get the distance from the current time to the start of the next possible ruleset.\n        // If the simulated ruleset must not yet have started, the start time of the simulated ruleset must be in the\n        // future.\n        uint256 mustStartAtOrAfter = !allowMidRuleset ? block.timestamp + 1 : block.timestamp - baseRuleset.duration + 1;\n\n        // Calculate what the start time should be.\n        uint256 start = deriveStartFrom({\n            baseRulesetStart: baseRuleset.start,\n            baseRulesetDuration: baseRuleset.duration,\n            mustStartAtOrAfter: mustStartAtOrAfter\n        });\n\n        // Calculate what the cycle number should be.\n        uint256 rulesetCycleNumber = deriveCycleNumberFrom({\n            baseRulesetCycleNumber: baseRuleset.cycleNumber,\n            baseRulesetStart: baseRuleset.start,\n            baseRulesetDuration: baseRuleset.duration,\n            start: start\n        });\n\n        return JBRuleset({\n            cycleNumber: uint48(rulesetCycleNumber),\n            id: baseRuleset.id,\n            basedOnId: baseRuleset.basedOnId,\n            start: uint48(start),\n            duration: baseRuleset.duration,\n            weight: uint112(\n                deriveWeightFrom({\n                    projectId: projectId,\n                    baseRulesetStart: baseRuleset.start,\n                    baseRulesetDuration: baseRuleset.duration,\n                    baseRulesetWeight: baseRuleset.weight,\n                    baseRulesetWeightCutPercent: baseRuleset.weightCutPercent,\n                    baseRulesetCacheId: baseRuleset.id,\n                    start: start\n                })\n            ),\n            weightCutPercent: baseRuleset.weightCutPercent,\n            approvalHook: baseRuleset.approvalHook,\n            metadata: baseRuleset.metadata\n        });\n    }\n\n    /// @notice The ruleset up next for a project, if one exists, whether or not that ruleset has been approved.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a `latestRulesetIdOf` value.\n    /// @param projectId The ID of the project to check for an upcoming approvable ruleset.\n    /// @return rulesetId The `rulesetId` of the upcoming approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _upcomingApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256 rulesetId) {\n        // Get a reference to the ID of the project's latest ruleset.\n        rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // There is no upcoming ruleset if the latest ruleset has already started.\n        // slither-disable-next-line incorrect-equality\n        if (block.timestamp >= ruleset.start) return 0;\n\n        // If this is the first ruleset, it is queued.\n        // slither-disable-next-line incorrect-equality\n        if (ruleset.cycleNumber == 1) return rulesetId;\n\n        // Get a reference to the ID of the ruleset the latest ruleset was based on.\n        uint256 basedOnId = ruleset.basedOnId;\n\n        // Get the necessary properties for the base ruleset.\n        JBRuleset memory baseRuleset;\n\n        // Find the base ruleset that is not still queued.\n        while (true) {\n            baseRuleset = _getStructFor(projectId, basedOnId);\n\n            // If the base ruleset starts in the future,\n            if (block.timestamp < baseRuleset.start) {\n                // Set the `rulesetId` to the one found.\n                rulesetId = baseRuleset.id;\n                // Check the ruleset it was based on in the next iteration.\n                basedOnId = baseRuleset.basedOnId;\n            } else {\n                // Break out of the loop when a base ruleset which has already started is found.\n                break;\n            }\n        }\n\n        // Get the ruleset struct for the ID found.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // If the latest ruleset doesn't start until after another base ruleset return 0.\n        if (baseRuleset.duration != 0 && block.timestamp < ruleset.start - baseRuleset.duration) {\n            return 0;\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Queues the upcoming approvable ruleset for the specified project.\n    /// @dev Only a project's current controller can queue its rulesets.\n    /// @param projectId The ID of the project to queue the ruleset for.\n    /// @param duration The number of seconds the ruleset lasts for, after which a new ruleset starts.\n    /// - A `duration` of 0 means this ruleset will remain active until the project owner queues a new ruleset. That new\n    /// ruleset will start immediately.\n    /// - A ruleset with a non-zero `duration` applies until the duration ends â€“ any newly queued rulesets will be\n    /// *queued* to take effect afterwards.\n    /// - If a duration ends and no new rulesets are queued, the ruleset rolls over to a new ruleset with the same rules\n    /// (except for a new `start` timestamp and a cut `weight`).\n    /// @param weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations on.\n    /// Payment terminals generally use this to determine how many tokens should be minted when the project is paid.\n    /// @param weightCutPercent A fraction (out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`) to reduce the next ruleset's\n    /// `weight`\n    /// by.\n    /// - If a ruleset specifies a non-zero `weight`, the `weightCutPercent` does not apply.\n    /// - If the `weightCutPercent` is 0, the `weight` stays the same.\n    /// - If the `weightCutPercent` is 10% of `JBConstants.MAX_WEIGHT_CUT_PERCENT`, next ruleset's `weight` will be 90%\n    /// of the\n    /// current\n    /// one.\n    /// @param approvalHook A contract which dictates whether a proposed ruleset should be accepted or rejected. It can\n    /// be used to constrain a project owner's ability to change ruleset parameters over time.\n    /// @param metadata Arbitrary extra data to associate with this ruleset. This metadata is not used by `JBRulesets`.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return The struct of the new ruleset.\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n        returns (JBRuleset memory)\n    {\n        // Duration must fit in a uint32.\n        if (duration > type(uint32).max) revert JBRulesets_InvalidRulesetDuration(duration, type(uint32).max);\n\n        // Weight cut percent must be less than or equal to 100%.\n        if (weightCutPercent > JBConstants.MAX_WEIGHT_CUT_PERCENT) {\n            revert JBRulesets_InvalidWeightCutPercent(weightCutPercent);\n        }\n\n        // Weight must fit into a uint112.\n        if (weight > type(uint112).max) revert JBRulesets_InvalidWeight(weight, type(uint112).max);\n\n        // If the start date is not set, set it to be the current timestamp.\n        if (mustStartAtOrAfter == 0) {\n            mustStartAtOrAfter = block.timestamp;\n        }\n\n        // Make sure the min start date fits in a uint48, and that the start date of the following ruleset will also fit\n        // within the max.\n        if (mustStartAtOrAfter + duration > type(uint48).max) {\n            revert JBRulesets_InvalidRulesetEndTime(mustStartAtOrAfter + duration, type(uint48).max);\n        }\n\n        // Approval hook should be a valid contract, supporting the correct interface\n        if (approvalHook != IJBRulesetApprovalHook(address(0))) {\n            // Revert if there isn't a contract at the address\n            if (address(approvalHook).code.length == 0) revert JBRulesets_InvalidRulesetApprovalHook(approvalHook);\n\n            // Make sure the approval hook supports the expected interface.\n            try approvalHook.supportsInterface(type(IJBRulesetApprovalHook).interfaceId) returns (bool doesSupport) {\n                if (!doesSupport) revert JBRulesets_InvalidRulesetApprovalHook(approvalHook); // Contract exists at the\n                    // address but\n                    // with the\n                    // wrong interface\n            } catch {\n                revert JBRulesets_InvalidRulesetApprovalHook(approvalHook); // No ERC165 support\n            }\n        }\n\n        // Get a reference to the latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // The new rulesetId timestamp is now, or an increment from now if the current timestamp is taken.\n        uint256 rulesetId = latestId >= block.timestamp ? latestId + 1 : block.timestamp;\n\n        // Set up the ruleset by configuring intrinsic properties.\n        _configureIntrinsicPropertiesFor(projectId, rulesetId, weight, mustStartAtOrAfter);\n\n        // Efficiently stores the ruleset's user-defined properties.\n        // If all user config properties are zero, no need to store anything as the default value will have the same\n        // outcome.\n        if (approvalHook != IJBRulesetApprovalHook(address(0)) || duration > 0 || weightCutPercent > 0) {\n            // approval hook in bits 0-159 bytes.\n            uint256 packed = uint160(address(approvalHook));\n\n            // duration in bits 160-191 bytes.\n            packed |= duration << 160;\n\n            // weightCutPercent in bits 192-223 bytes.\n            packed |= weightCutPercent << 192;\n\n            // Set in storage.\n            _packedUserPropertiesOf[projectId][rulesetId] = packed;\n        }\n\n        // Set the metadata if needed.\n        if (metadata > 0) _metadataOf[projectId][rulesetId] = metadata;\n\n        emit RulesetQueued({\n            rulesetId: rulesetId,\n            projectId: projectId,\n            duration: duration,\n            weight: weight,\n            weightCutPercent: weightCutPercent,\n            approvalHook: approvalHook,\n            metadata: metadata,\n            mustStartAtOrAfter: mustStartAtOrAfter,\n            caller: msg.sender\n        });\n\n        // Return the struct for the new ruleset's ID.\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice Cache the value of the ruleset weight.\n    /// @param projectId The ID of the project having its ruleset weight cached.\n    function updateRulesetWeightCache(uint256 projectId) external override {\n        // Keep a reference to the struct for the latest queued ruleset.\n        // The cached value will be based on this struct.\n        JBRuleset memory latestQueuedRuleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n        // Nothing to cache if the latest ruleset doesn't have a duration or a weight cut percent.\n        // slither-disable-next-line incorrect-equality\n        if (latestQueuedRuleset.duration == 0 || latestQueuedRuleset.weightCutPercent == 0) return;\n\n        // Get a reference to the current cache.\n        JBRulesetWeightCache storage cache = _weightCacheOf[projectId][latestQueuedRuleset.id];\n\n        // Determine the largest start timestamp the cache can be filled to.\n        uint256 maxStart = latestQueuedRuleset.start\n            + (cache.weightCutMultiple + _MAX_WEIGHT_CUT_MULTIPLE_CACHE_THRESHOLD) * latestQueuedRuleset.duration;\n\n        // Determine the start timestamp to derive a weight from for the cache.\n        uint256 start = block.timestamp < maxStart ? block.timestamp : maxStart;\n\n        // The difference between the start of the latest queued ruleset and the start of the ruleset we're caching the\n        // weight of.\n        uint256 startDistance = start - latestQueuedRuleset.start;\n\n        // Calculate the weight cut multiple.\n        uint168 weightCutMultiple;\n        unchecked {\n            weightCutMultiple = uint168(startDistance / latestQueuedRuleset.duration);\n        }\n\n        // Store the new values.\n        cache.weight = uint112(\n            deriveWeightFrom({\n                projectId: projectId,\n                baseRulesetStart: latestQueuedRuleset.start,\n                baseRulesetDuration: latestQueuedRuleset.duration,\n                baseRulesetWeight: latestQueuedRuleset.weight,\n                baseRulesetWeightCutPercent: latestQueuedRuleset.weightCutPercent,\n                baseRulesetCacheId: latestQueuedRuleset.id,\n                start: start\n            })\n        );\n        cache.weightCutMultiple = weightCutMultiple;\n\n        emit WeightCacheUpdated({\n            projectId: projectId,\n            weight: cache.weight,\n            weightCutMultiple: weightCutMultiple,\n            caller: msg.sender\n        });\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Updates the latest ruleset for this project if it exists. If there is no ruleset, initializes one.\n    /// @param projectId The ID of the project to update the latest ruleset for.\n    /// @param rulesetId The timestamp of when the ruleset was queued.\n    /// @param weight The weight to store in the queued ruleset.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    function _configureIntrinsicPropertiesFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 weight,\n        uint256 mustStartAtOrAfter\n    )\n        internal\n    {\n        // Keep a reference to the project's latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // If the project doesn't have a ruleset yet, initialize one.\n        // slither-disable-next-line incorrect-equality\n        if (latestId == 0) {\n            // Use an empty ruleset as the base.\n            return _initializeRulesetFor({\n                projectId: projectId,\n                baseRuleset: _getStructFor(0, 0),\n                rulesetId: rulesetId,\n                mustStartAtOrAfter: mustStartAtOrAfter,\n                weight: weight\n            });\n        }\n\n        // Get a reference to the latest ruleset's struct.\n        JBRuleset memory baseRuleset = _getStructFor(projectId, latestId);\n\n        // Get a reference to the approval status.\n        JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, baseRuleset);\n\n        // If the base ruleset has started but wasn't approved if a approval hook exists\n        // OR it hasn't started but is currently approved\n        // OR it hasn't started but it is likely to be approved and takes place before the proposed one,\n        // set the struct to be the ruleset it's based on, which carries the latest approved ruleset.\n        if (\n            (\n                block.timestamp >= baseRuleset.start && approvalStatus != JBApprovalStatus.Approved\n                    && approvalStatus != JBApprovalStatus.Empty\n            )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter < baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved\n                )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter >= baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.ApprovalExpected\n                        && approvalStatus != JBApprovalStatus.Empty\n                )\n        ) {\n            baseRuleset = _getStructFor(projectId, baseRuleset.basedOnId);\n        }\n\n        // The time when the duration of the base ruleset's approval hook has finished.\n        // If the provided ruleset has no approval hook, return 0 (no constraint on start time).\n        uint256 timestampAfterApprovalHook = baseRuleset.approvalHook == IJBRulesetApprovalHook(address(0))\n            ? 0\n            : rulesetId + baseRuleset.approvalHook.DURATION();\n\n        _initializeRulesetFor({\n            projectId: projectId,\n            baseRuleset: baseRuleset,\n            rulesetId: rulesetId,\n            // Can only start after the approval hook.\n            mustStartAtOrAfter: timestampAfterApprovalHook > mustStartAtOrAfter\n                ? timestampAfterApprovalHook\n                : mustStartAtOrAfter,\n            weight: weight\n        });\n    }\n\n    /// @notice Initializes a ruleset with the specified properties.\n    /// @param projectId The ID of the project to initialize the ruleset for.\n    /// @param baseRuleset The ruleset struct to base the newly initialized one on.\n    /// @param rulesetId The `rulesetId` for the ruleset being initialized.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @param weight The weight to give the newly initialized ruleset.\n    function _initializeRulesetFor(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        uint256 rulesetId,\n        uint256 mustStartAtOrAfter,\n        uint256 weight\n    )\n        internal\n    {\n        // If there is no base, initialize a first ruleset.\n        // slither-disable-next-line incorrect-equality\n        if (baseRuleset.cycleNumber == 0) {\n            // Set fresh intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: 1,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: mustStartAtOrAfter\n            });\n        } else {\n            // Derive the correct next start time from the base.\n            uint256 start = deriveStartFrom({\n                baseRulesetStart: baseRuleset.start,\n                baseRulesetDuration: baseRuleset.duration,\n                mustStartAtOrAfter: mustStartAtOrAfter\n            });\n\n            // A weight of 1 is a special case that represents inheriting the cut weight of the previous\n            // ruleset.\n            weight = weight == 1\n                ? deriveWeightFrom({\n                    projectId: projectId,\n                    baseRulesetStart: baseRuleset.start,\n                    baseRulesetDuration: baseRuleset.duration,\n                    baseRulesetWeight: baseRuleset.weight,\n                    baseRulesetWeightCutPercent: baseRuleset.weightCutPercent,\n                    baseRulesetCacheId: baseRuleset.id,\n                    start: start\n                })\n                : weight;\n\n            // Derive the correct ruleset cycle number.\n            uint256 rulesetCycleNumber = deriveCycleNumberFrom({\n                baseRulesetCycleNumber: baseRuleset.cycleNumber,\n                baseRulesetStart: baseRuleset.start,\n                baseRulesetDuration: baseRuleset.duration,\n                start: start\n            });\n\n            // Update the intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: rulesetCycleNumber,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: start\n            });\n        }\n\n        // Set the project's latest ruleset configuration.\n        latestRulesetIdOf[projectId] = rulesetId;\n\n        emit RulesetInitialized({\n            rulesetId: rulesetId,\n            projectId: projectId,\n            basedOnId: baseRuleset.id,\n            caller: msg.sender\n        });\n    }\n\n    /// @notice Efficiently stores the provided intrinsic properties of a ruleset.\n    /// @param rulesetId The `rulesetId` of the ruleset to pack and store for.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetCycleNumber The cycle number of the ruleset.\n    /// @param weight The weight of the ruleset.\n    /// @param basedOnId The `rulesetId` of the ruleset this ruleset was based on.\n    /// @param start The start time of this ruleset.\n    function _packAndStoreIntrinsicPropertiesOf(\n        uint256 rulesetId,\n        uint256 projectId,\n        uint256 rulesetCycleNumber,\n        uint256 weight,\n        uint256 basedOnId,\n        uint256 start\n    )\n        internal\n    {\n        // `weight` in bits 0-111.\n        uint256 packed = weight;\n\n        // `basedOnId` in bits 112-159.\n        packed |= basedOnId << 112;\n\n        // `start` in bits 160-207.\n        packed |= start << 160;\n\n        // cycle number in bits 208-255.\n        packed |= rulesetCycleNumber << 208;\n\n        // Store the packed value.\n        _packedIntrinsicPropertiesOf[projectId][rulesetId] = packed;\n    }\n}\n"},"src/interfaces/IJBRulesets.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"},"src/abstract/JBControlled.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBControlled} from \"./../interfaces/IJBControlled.sol\";\nimport {IJBDirectory} from \"./../interfaces/IJBDirectory.sol\";\n\n/// @notice Provides a modifier for contracts with functionality that can only be accessed by a project's controller.\nabstract contract JBControlled is IJBControlled {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBControlled_ControllerUnauthorized(address controller);\n\n    //*********************************************************************//\n    // ---------------------------- modifiers ---------------------------- //\n    //*********************************************************************//\n\n    /// @notice Only allows the controller of the specified project to proceed.\n    /// @param projectId The ID of the project.\n    modifier onlyControllerOf(uint256 projectId) {\n        _onlyControllerOf(projectId);\n        _;\n    }\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    constructor(IJBDirectory directory) {\n        DIRECTORY = directory;\n    }\n\n    /// @notice Only allows the controller of the specified project to proceed.\n    function _onlyControllerOf(uint256 projectId) internal view {\n        if (address(DIRECTORY.controllerOf(projectId)) != msg.sender) {\n            revert JBControlled_ControllerUnauthorized(address(DIRECTORY.controllerOf(projectId)));\n        }\n    }\n}\n"},"src/structs/JBAccountingContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"},"src/enums/JBApprovalStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"},"src/interfaces/IJBRulesetApprovalHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) external view returns (JBApprovalStatus);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"src/interfaces/IJBProjects.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"},"src/interfaces/IJBTokenUriResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"},"src/interfaces/IJBPayHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"},"src/libraries/JBConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"},"src/structs/JBRuleset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"},"src/structs/JBRulesetWeightCache.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member weight The cached weight value.\n/// @custom:member weightCutMultiple The weight cut multiple that produces the given weight.\nstruct JBRulesetWeightCache {\n    uint112 weight;\n    uint168 weightCutMultiple;\n}\n"},"src/structs/JBTokenAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"},"src/interfaces/IJBDirectory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"node_modules/@prb/math/src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*yÃ·denominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*yÃ·1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*yÃ·denominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*yÃ·denominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"},"src/interfaces/IJBTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"},"src/structs/JBAfterPayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"}},"settings":{"evmVersion":"paris","metadata":{"appendCBOR":true,"bytecodeHash":"ipfs","useLiteralContent":false},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/","@arbitrum/=node_modules/@arbitrum/","@bananapus/=node_modules/@bananapus/","@chainlink/=node_modules/@chainlink/","@eth-optimism/=node_modules/@eth-optimism/","@offchainlabs/=node_modules/@offchainlabs/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@scroll-tech/=node_modules/@scroll-tech/","@uniswap/=node_modules/@uniswap/","@zksync/=node_modules/@zksync/","forge-std/=lib/forge-std/src/","hardhat/=node_modules/hardhat/","solmate/=node_modules/solmate/","sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"],"viaIR":false}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"directory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"JBControlled_ControllerUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"hook\",\"type\":\"address\"}],\"name\":\"JBRulesets_InvalidRulesetApprovalHook\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBRulesets_InvalidRulesetDuration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBRulesets_InvalidRulesetEndTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBRulesets_InvalidWeight\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"JBRulesets_InvalidWeightCutPercent\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"basedOnId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RulesetInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weightCutPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RulesetQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weightCutMultiple\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"WeightCacheUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DIRECTORY\",\"outputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"allOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset[]\",\"name\":\"rulesets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"currentApprovalStatusForLatestRulesetOf\",\"outputs\":[{\"internalType\":\"enum JBApprovalStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"currentOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseRulesetCycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"deriveCycleNumberFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseRulesetStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint256\"}],\"name\":\"deriveStartFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetWeight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetWeightCutPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseRulesetCacheId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"}],\"name\":\"deriveWeightFrom\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"}],\"name\":\"getRulesetOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"latestQueuedOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"internalType\":\"enum JBApprovalStatus\",\"name\":\"approvalStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"latestRulesetIdOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weightCutPercent\",\"type\":\"uint256\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint256\"}],\"name\":\"queueFor\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"upcomingOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"updateRulesetWeightCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"JBRulesets","CompilerVersion":"v0.8.23+commit.f704f362","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000000061e516886a0540f63157f112c0588ee0651dcf","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}