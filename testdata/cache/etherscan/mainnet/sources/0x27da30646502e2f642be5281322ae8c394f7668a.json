{"expiry":6055833344,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/interfaces/IJBTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"},"src/libraries/JBRulesetMetadataResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function cashOutTaxRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Cash out tax rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function useTotalSurplusForCashOuts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 80) & 1 == 1;\n    }\n\n    function useDataHookForCashOut(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 82));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 242);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // cash out tax rate in bits 20-35 (16 bits).\n        // cash out tax rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.cashOutTaxRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow controller migration in bit 77.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 77;\n        // hold fees in bit 78.\n        if (rulesetMetadata.holdFees) packed |= 1 << 78;\n        // useTotalSurplusForCashOuts in bit 79.\n        if (rulesetMetadata.useTotalSurplusForCashOuts) packed |= 1 << 79;\n        // use pay data source in bit 80.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 80;\n        // use cash out data source in bit 81.\n        if (rulesetMetadata.useDataHookForCashOut) packed |= 1 << 81;\n        // data source address in bits 82-241.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 82;\n        // metadata in bits 242-255 (14 bits).\n        packed |= (uint256(rulesetMetadata.metadata) & 0x3FFF) << 242;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            cashOutTaxRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForCashOuts(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForCashOut(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"},"src/structs/JBBeforePayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedPercent The reserved percent of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedPercent;\n    bytes metadata;\n}\n"},"src/enums/JBApprovalStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"},"src/interfaces/IJBPrices.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"},"src/structs/JBBeforeCashOutRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon cash out.\n/// @custom:member terminal The terminal that is facilitating the cash out.\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project whose tokens are being cashed out.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of tokens being cashed out, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making cash outs.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset the cash out is being made during.\n/// @custom:member metadata Extra data provided by the casher.\nstruct JBBeforeCashOutRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 cashOutTaxRate;\n    bytes metadata;\n}\n"},"src/JBController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids-v5/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./interfaces/IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./interfaces/IJBFundAccessLimits.sol\";\nimport {IJBMigratable} from \"./interfaces/IJBMigratable.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBPriceFeed} from \"./interfaces/IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./interfaces/IJBProjectUriRegistry.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBToken} from \"./interfaces/IJBToken.sol\";\nimport {IJBTokens} from \"./interfaces/IJBTokens.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBSplitGroupIds} from \"./libraries/JBSplitGroupIds.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./structs/JBSplitGroup.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTerminalConfig} from \"./structs/JBTerminalConfig.sol\";\n\n/// @notice `JBController` coordinates rulesets and project tokens, and is the entry point for most operations related\n/// to rulesets and project tokens.\ncontract JBController is JBPermissioned, ERC2771Context, IJBController, IJBMigratable {\n    // A library that parses packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JBController_AddingPriceFeedNotAllowed();\n    error JBController_CreditTransfersPaused();\n    error JBController_InvalidCashOutTaxRate(uint256 rate, uint256 limit);\n    error JBController_InvalidReservedPercent(uint256 percent, uint256 limit);\n    error JBController_MintNotAllowedAndNotTerminalOrHook();\n    error JBController_NoReservedTokens();\n    error JBController_OnlyDirectory(address sender, IJBDirectory directory);\n    error JBController_PendingReservedTokens(uint256 pendingReservedTokenBalance);\n    error JBController_RulesetsAlreadyLaunched();\n    error JBController_RulesetsArrayEmpty();\n    error JBController_RulesetSetTokenNotAllowed();\n    error JBController_ZeroTokensToBurn();\n    error JBController_ZeroTokensToMint();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice A contract that stores fund access limits for each project.\n    IJBFundAccessLimits public immutable override FUND_ACCESS_LIMITS;\n\n    /// @notice A contract that stores prices for each project.\n    IJBPrices public immutable override PRICES;\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens public immutable override TOKENS;\n\n    /// @notice The address of the contract that manages omnichain ruleset ops.\n    address public immutable OMNICHAIN_RULESET_OPERATOR;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's unrealized reserved token balance (i.e. reserved tokens which haven't been sent out to the\n    /// reserved token split group yet).\n    /// @custom:param projectId The ID of the project to get the pending reserved token balance of.\n    mapping(uint256 projectId => uint256) public override pendingReservedTokenBalanceOf;\n\n    /// @notice The metadata URI for each project. This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @custom:param projectId The ID of the project to get the metadata URI of.\n    mapping(uint256 projectId => string) public override uriOf;\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param fundAccessLimits A contract that stores fund access limits for each project.\n    /// @param permissions A contract storing permissions.\n    /// @param prices A contract that stores prices for each project.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param splits A contract that stores splits for each project.\n    /// @param tokens A contract that manages token minting and burning.\n    /// @param omnichainRulesetOperator The address of the contract that manages omnichain ruleset ops.\n    /// @param trustedForwarder The trusted forwarder for the ERC2771Context.\n    constructor(\n        IJBDirectory directory,\n        IJBFundAccessLimits fundAccessLimits,\n        IJBPermissions permissions,\n        IJBPrices prices,\n        IJBProjects projects,\n        IJBRulesets rulesets,\n        IJBSplits splits,\n        IJBTokens tokens,\n        address omnichainRulesetOperator,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        DIRECTORY = directory;\n        FUND_ACCESS_LIMITS = fundAccessLimits;\n        PRICES = prices;\n        PROJECTS = projects;\n        RULESETS = rulesets;\n        SPLITS = splits;\n        TOKENS = tokens;\n        OMNICHAIN_RULESET_OPERATOR = omnichainRulesetOperator;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get an array of a project's rulesets (with metadata) up to a maximum array size, sorted from latest to\n    /// earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If the\n    /// `startingId` is 0, passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The array of rulesets with their metadata.\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRulesetWithMetadata[] memory rulesets)\n    {\n        // Get the rulesets (without metadata).\n        JBRuleset[] memory baseRulesets = RULESETS.allOf(projectId, startingId, size);\n\n        // Keep a reference to the number of rulesets.\n        uint256 numberOfRulesets = baseRulesets.length;\n\n        // Initialize the array being returned.\n        rulesets = new JBRulesetWithMetadata[](numberOfRulesets);\n\n        // Populate the array with rulesets AND their metadata.\n        for (uint256 i; i < numberOfRulesets; i++) {\n            // Set the ruleset being iterated on.\n            JBRuleset memory baseRuleset = baseRulesets[i];\n\n            // Set the returned value.\n            rulesets[i] = JBRulesetWithMetadata({ruleset: baseRuleset, metadata: baseRuleset.expandMetadata()});\n        }\n    }\n\n    /// @notice A project's currently active ruleset and its metadata.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The current ruleset's struct.\n    /// @return metadata The current ruleset's metadata.\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = _currentRulesetOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Get the `JBRuleset` and `JBRulesetMetadata` corresponding to the specified `rulesetId`.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @return ruleset The ruleset's struct.\n    /// @return metadata The ruleset's metadata.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = RULESETS.getRulesetOf(projectId, rulesetId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Gets the latest ruleset queued for a project, its approval status, and its metadata.\n    /// @dev The 'latest queued ruleset' is the ruleset initialized furthest in the future (at the end of the ruleset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest ruleset of.\n    /// @return ruleset The struct for the project's latest queued ruleset.\n    /// @return metadata The ruleset's metadata.\n    /// @return approvalStatus The ruleset's approval status.\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata, JBApprovalStatus approvalStatus)\n    {\n        (ruleset, approvalStatus) = RULESETS.latestQueuedOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Check whether the project's terminals can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows terminals to be set.\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool) {\n        return _currentRulesetOf(projectId).expandMetadata().allowSetTerminals;\n    }\n\n    /// @notice Check whether the project's controller can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows controllers to be set.\n    function setControllerAllowed(uint256 projectId) external view returns (bool) {\n        return _currentRulesetOf(projectId).expandMetadata().allowSetController;\n    }\n\n    /// @notice Gets the a project token's total supply, including pending reserved tokens.\n    /// @param projectId The ID of the project to get the total token supply of.\n    /// @return The total supply of the project's token, including pending reserved tokens.\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view override returns (uint256) {\n        // Add the reserved tokens to the total supply.\n        return TOKENS.totalSupplyOf(projectId) + pendingReservedTokenBalanceOf[projectId];\n    }\n\n    /// @notice A project's next ruleset along with its metadata.\n    /// @dev If an upcoming ruleset isn't found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the next ruleset of.\n    /// @return ruleset The upcoming ruleset's struct.\n    /// @return metadata The upcoming ruleset's metadata.\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = _upcomingRulesetOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IJBController).interfaceId || interfaceId == type(IJBProjectUriRegistry).interfaceId\n            || interfaceId == type(IJBDirectoryAccessControl).interfaceId || interfaceId == type(IJBMigratable).interfaceId\n            || interfaceId == type(IJBPermissioned).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice The project's current ruleset.\n    /// @param projectId The ID of the project to check.\n    /// @return The project's current ruleset.\n    function _currentRulesetOf(uint256 projectId) internal view returns (JBRuleset memory) {\n        return RULESETS.currentOf(projectId);\n    }\n\n    /// @notice Indicates whether the provided address is a terminal for the project.\n    /// @param projectId The ID of the project to check.\n    /// @param terminal The address to check.\n    /// @return A flag indicating if the provided address is a terminal for the project.\n    function _isTerminalOf(uint256 projectId, address terminal) internal view returns (bool) {\n        return DIRECTORY.isTerminalOf(projectId, IJBTerminal(terminal));\n    }\n\n    /// @notice Indicates whether the provided address has mint permission for the project byway of the data hook.\n    /// @param projectId The ID of the project to check.\n    /// @param ruleset The ruleset to check.\n    /// @param addr The address to check.\n    /// @return A flag indicating if the provided address has mint permission for the project.\n    function _hasDataHookMintPermissionFor(\n        uint256 projectId,\n        JBRuleset memory ruleset,\n        address addr\n    )\n        internal\n        view\n        returns (bool)\n    {\n        address dataHook = ruleset.dataHook();\n\n        return dataHook != address(0)\n            && IJBRulesetDataHook(dataHook).hasMintPermissionFor({projectId: projectId, ruleset: ruleset, addr: addr});\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The project's upcoming ruleset.\n    /// @param projectId The ID of the project to check.\n    /// @return The project's upcoming ruleset.\n    function _upcomingRulesetOf(uint256 projectId) internal view returns (JBRuleset memory) {\n        return RULESETS.upcomingOf(projectId);\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Add a price feed for a project.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `ADD_PRICE_FEED`.\n    /// @param projectId The ID of the project to add the feed for.\n    /// @param pricingCurrency The currency the feed's output price is in terms of.\n    /// @param unitCurrency The currency being priced by the feed.\n    /// @param feed The address of the price feed to add.\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.ADD_PRICE_FEED\n        });\n\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Make sure the project's ruleset allows adding price feeds.\n        if (!ruleset.allowAddPriceFeed()) revert JBController_AddingPriceFeedNotAllowed();\n\n        PRICES.addPriceFeedFor({\n            projectId: projectId,\n            pricingCurrency: pricingCurrency,\n            unitCurrency: unitCurrency,\n            feed: feed\n        });\n    }\n\n    /// @notice Prepares this controller to receive a project being migrated from another controller.\n    /// @dev This controller should not be the project's controller yet.\n    /// @param from The controller being migrated from.\n    /// @param projectId The ID of the project that will migrate to this controller.\n    function beforeReceiveMigrationFrom(IERC165 from, uint256 projectId) external override {\n        // Keep a reference to the sender.\n        address sender = _msgSender();\n\n        // Make sure the sender is the expected source controller.\n        if (sender != address(DIRECTORY)) revert JBController_OnlyDirectory(sender, DIRECTORY);\n\n        // If the sending controller is an `IJBProjectUriRegistry`, copy the project's metadata URI.\n        if (from.supportsInterface(type(IJBProjectUriRegistry).interfaceId)) {\n            uriOf[projectId] = IJBProjectUriRegistry(address(from)).uriOf(projectId);\n        }\n\n        // Send the pending reserved tokens to the splits.\n        if (\n            from.supportsInterface(type(IJBController).interfaceId)\n                && IJBController(address(from)).pendingReservedTokenBalanceOf(projectId) > 0\n        ) {\n            // slither-disable-next-line unused-return\n            IJBController(address(from)).sendReservedTokensToSplitsOf(projectId);\n        }\n    }\n\n    /// @notice Burns a project's tokens or credits from the specific holder's balance.\n    /// @dev Can only be called by the holder, an address with the holder's permission to `BURN_TOKENS`, or a project's\n    /// terminal.\n    /// @param holder The address whose tokens are being burned.\n    /// @param projectId The ID of the project whose tokens are being burned.\n    /// @param tokenCount The number of tokens to burn.\n    /// @param memo A memo to pass along to the emitted event.\n    function burnTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 tokenCount,\n        string calldata memo\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: holder,\n            projectId: projectId,\n            permissionId: JBPermissionIds.BURN_TOKENS,\n            alsoGrantAccessIf: _isTerminalOf(projectId, _msgSender())\n        });\n\n        // There must be tokens to burn.\n        if (tokenCount == 0) revert JBController_ZeroTokensToBurn();\n\n        emit BurnTokens({holder: holder, projectId: projectId, tokenCount: tokenCount, memo: memo, caller: _msgSender()});\n\n        // Burn the tokens.\n        TOKENS.burnFrom({holder: holder, projectId: projectId, count: tokenCount});\n    }\n\n    /// @notice Redeem credits to claim tokens into a `beneficiary`'s account.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `CLAIM_TOKENS`.\n    /// @param holder The address to redeem credits from.\n    /// @param projectId The ID of the project whose tokens are being claimed.\n    /// @param tokenCount The number of tokens to claim.\n    /// @param beneficiary The account the claimed tokens will go to.\n    function claimTokensFor(\n        address holder,\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.CLAIM_TOKENS});\n\n        TOKENS.claimTokensFor({holder: holder, projectId: projectId, count: tokenCount, beneficiary: beneficiary});\n    }\n\n    /// @notice Deploys an ERC-20 token for a project. It will be used when claiming tokens (with credits).\n    /// @dev Deploys the project's ERC-20 contract.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `DEPLOY_ERC20`.\n    /// @param projectId The ID of the project to deploy the ERC-20 for.\n    /// @param name The ERC-20's name.\n    /// @param symbol The ERC-20's symbol.\n    /// @param salt The salt used for ERC-1167 clone deployment. Pass a non-zero salt for deterministic deployment based\n    /// on `msg.sender` and the `TOKEN` implementation address.\n    /// @return token The address of the token that was deployed.\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        override\n        returns (IJBToken token)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_ERC20\n        });\n\n        // If a salt is provided, use it.\n        bytes32 saltHash = salt != bytes32(0) ? keccak256(abi.encodePacked(_msgSender(), salt)) : bytes32(0);\n\n        // Emit the event.\n        emit DeployERC20({\n            projectId: projectId,\n            deployer: _msgSender(),\n            salt: salt,\n            saltHash: saltHash,\n            caller: _msgSender()\n        });\n\n        // Deploy the ERC-20 token with the hashed salt.\n        return TOKENS.deployERC20For({projectId: projectId, name: name, symbol: symbol, salt: saltHash});\n    }\n\n    /// @notice When a project receives reserved tokens, if it has a terminal for the token, this is used to pay the\n    /// terminal.\n    /// @dev Can only be called by this controller.\n    /// @param terminal The terminal to pay.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The token being paid with.\n    /// @param splitTokenCount The number of tokens being paid.\n    /// @param beneficiary The payment's beneficiary.\n    /// @param metadata The pay metadata sent to the terminal.\n    function executePayReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitTokenCount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n    {\n        // Can only be called by this contract.\n        require(msg.sender == address(this));\n\n        // Approve the tokens being paid.\n        IERC20(address(token)).forceApprove(address(terminal), splitTokenCount);\n\n        // slither-disable-next-line unused-return\n        terminal.pay({\n            projectId: projectId,\n            token: address(token),\n            amount: splitTokenCount,\n            beneficiary: beneficiary,\n            minReturnedTokens: 0,\n            memo: \"\",\n            metadata: metadata\n        });\n\n        // Make sure that the terminal received the tokens.\n        assert(IERC20(address(token)).allowance(address(this), address(terminal)) == 0);\n    }\n\n    /// @notice Creates a project.\n    /// @dev This will mint the project's ERC-721 to the `owner`'s address, queue the specified rulesets, and set up the\n    /// specified splits and terminals. Each operation within this transaction can be done in sequence separately.\n    /// @dev Anyone can deploy a project to any `owner`'s address.\n    /// @param owner The project's owner. The project ERC-721 will be minted to this address.\n    /// @param projectUri The project's metadata URI. This is typically an IPFS hash, optionally with the `ipfs://`\n    /// prefix. This can be updated by the project's owner.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up for the project.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return projectId The project's ID.\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 projectId)\n    {\n        // Mint the project ERC-721 into the owner's wallet.\n        // slither-disable-next-line reentrancy-benign\n        projectId = PROJECTS.createFor(owner);\n\n        // If provided, set the project's metadata URI.\n        if (bytes(projectUri).length > 0) {\n            uriOf[projectId] = projectUri;\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        // Queue the rulesets.\n        // slither-disable-next-line reentrancy-events\n        uint256 rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit LaunchProject({\n            rulesetId: rulesetId,\n            projectId: projectId,\n            projectUri: projectUri,\n            memo: memo,\n            caller: _msgSender()\n        });\n    }\n\n    /// @notice Queue a project's initial rulesets and set up terminals for it. Projects which already have rulesets\n    /// should use `queueRulesetsOf(...)`.\n    /// @dev Each operation within this transaction can be done in sequence separately.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to launch rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last successfully queued ruleset.\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 rulesetId)\n    {\n        // Make sure there are rulesets being queued.\n        if (rulesetConfigurations.length == 0) revert JBController_RulesetsArrayEmpty();\n\n        // Keep a reference to the sender.\n        address sender = _msgSender();\n\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS,\n            alsoGrantAccessIf: sender == OMNICHAIN_RULESET_OPERATOR\n        });\n\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TERMINALS,\n            alsoGrantAccessIf: sender == OMNICHAIN_RULESET_OPERATOR\n        });\n\n        // If the project has already had rulesets, use `queueRulesetsOf(...)` instead.\n        if (RULESETS.latestRulesetIdOf(projectId) > 0) {\n            revert JBController_RulesetsAlreadyLaunched();\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        // Queue the first ruleset.\n        // slither-disable-next-line reentrancy-events\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit LaunchRulesets({rulesetId: rulesetId, projectId: projectId, memo: memo, caller: _msgSender()});\n    }\n\n    /// @notice Migrate a project from this controller to another one.\n    /// @dev Can only be called by the directory.\n    /// @param projectId The ID of the project to migrate.\n    /// @param to The controller to migrate the project to.\n    function migrate(uint256 projectId, IERC165 to) external override {\n        // Make sure this is being called by the directory.\n        if (msg.sender != address(DIRECTORY)) revert JBController_OnlyDirectory(msg.sender, DIRECTORY);\n\n        emit Migrate({projectId: projectId, to: to, caller: msg.sender});\n\n        // Get a reference to the project's pending reserved token balance.\n        uint256 pendingReservedTokenBalance = pendingReservedTokenBalanceOf[projectId];\n\n        // Mint any pending reserved tokens before migrating.\n        if (pendingReservedTokenBalance != 0) revert JBController_PendingReservedTokens(pendingReservedTokenBalance);\n    }\n\n    /// @notice Add new project tokens or credits to the specified beneficiary's balance. Optionally, reserve a portion\n    /// according to the ruleset's reserved percent.\n    /// @dev Can only be called by the project's owner, an address with the owner's permission to `MINT_TOKENS`, one of\n    /// the project's terminals, or the project's data hook.\n    /// @dev If the ruleset's metadata has `allowOwnerMinting` set to `false`, this function can only be called by the\n    /// project's terminals or data hook.\n    /// @param projectId The ID of the project whose tokens are being minted.\n    /// @param tokenCount The number of tokens to mint, including any reserved tokens.\n    /// @param beneficiary The address which will receive the (non-reserved) tokens.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param useReservedPercent Whether to apply the ruleset's reserved percent.\n    /// @return beneficiaryTokenCount The number of tokens minted for the `beneficiary`.\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // There should be tokens to mint.\n        if (tokenCount == 0) revert JBController_ZeroTokensToMint();\n\n        // Keep a reference to the reserved percent.\n        uint256 reservedPercent;\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Minting is restricted to: the project's owner, addresses with permission to `MINT_TOKENS`, the project's\n        // terminals, and the project's data hook.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MINT_TOKENS,\n            alsoGrantAccessIf: _isTerminalOf(projectId, _msgSender()) || _msgSender() == ruleset.dataHook()\n                || _hasDataHookMintPermissionFor(projectId, ruleset, _msgSender())\n        });\n\n        // If the message sender is not the project's terminal or data hook, the ruleset must have `allowOwnerMinting`\n        // set to `true`.\n        if (\n            ruleset.id != 0 && !ruleset.allowOwnerMinting() && !_isTerminalOf(projectId, _msgSender())\n                && _msgSender() != address(ruleset.dataHook())\n                && !_hasDataHookMintPermissionFor(projectId, ruleset, _msgSender())\n        ) revert JBController_MintNotAllowedAndNotTerminalOrHook();\n\n        // Determine the reserved percent to use.\n        reservedPercent = useReservedPercent ? ruleset.reservedPercent() : 0;\n\n        if (reservedPercent != JBConstants.MAX_RESERVED_PERCENT) {\n            // Calculate the number of (non-reserved) tokens that will be minted to the beneficiary.\n            beneficiaryTokenCount =\n                mulDiv(tokenCount, JBConstants.MAX_RESERVED_PERCENT - reservedPercent, JBConstants.MAX_RESERVED_PERCENT);\n\n            // Mint the tokens.\n            // slither-disable-next-line reentrancy-benign,reentrancy-events,unused-return\n            TOKENS.mintFor({holder: beneficiary, projectId: projectId, count: beneficiaryTokenCount});\n        }\n\n        emit MintTokens({\n            beneficiary: beneficiary,\n            projectId: projectId,\n            tokenCount: tokenCount,\n            beneficiaryTokenCount: beneficiaryTokenCount,\n            memo: memo,\n            reservedPercent: reservedPercent,\n            caller: _msgSender()\n        });\n\n        // Add any reserved tokens to the pending reserved token balance.\n        if (reservedPercent > 0) {\n            pendingReservedTokenBalanceOf[projectId] += tokenCount - beneficiaryTokenCount;\n        }\n    }\n\n    /// @notice Add one or more rulesets to the end of a project's ruleset queue. Rulesets take effect after the\n    /// previous ruleset in the queue ends, and only if they are approved by the previous ruleset's approval hook.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last ruleset which was successfully queued.\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 rulesetId)\n    {\n        // Make sure there are rulesets being queued.\n        if (rulesetConfigurations.length == 0) revert JBController_RulesetsArrayEmpty();\n\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS,\n            alsoGrantAccessIf: _msgSender() == OMNICHAIN_RULESET_OPERATOR\n        });\n\n        // Queue the rulesets.\n        // slither-disable-next-line reentrancy-events\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit QueueRulesets({rulesetId: rulesetId, projectId: projectId, memo: memo, caller: _msgSender()});\n    }\n\n    /// @notice Sends a project's pending reserved tokens to its reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return The amount of reserved tokens minted and sent.\n    function sendReservedTokensToSplitsOf(uint256 projectId) external override returns (uint256) {\n        return _sendReservedTokensToSplitsOf(projectId);\n    }\n\n    /// @notice Sets a project's split groups. The new split groups must include any current splits which are locked.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_SPLIT_GROUPS`.\n    /// @param projectId The ID of the project to set the split groups of.\n    /// @param rulesetId The ID of the ruleset the split groups should be active in. Use a `rulesetId` of 0 to set the\n    /// default split groups, which are used when a ruleset has no splits set. If there are no default splits and no\n    /// splits are set, all splits are sent to the project's owner.\n    /// @param splitGroups An array of split groups to set.\n    function setSplitGroupsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBSplitGroup[] calldata splitGroups\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_SPLIT_GROUPS\n        });\n\n        // Set the split groups.\n        SPLITS.setSplitGroupsOf({projectId: projectId, rulesetId: rulesetId, splitGroups: splitGroups});\n    }\n\n    /// @notice Set a project's token. If the project's token is already set, this will revert.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_TOKEN`.\n    /// @param projectId The ID of the project to set the token of.\n    /// @param token The new token's address.\n    function setTokenFor(uint256 projectId, IJBToken token) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TOKEN\n        });\n\n        // Get a reference to the current ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // If there's no current ruleset, get a reference to the upcoming one.\n        if (ruleset.id == 0) ruleset = _upcomingRulesetOf(projectId);\n\n        // If owner minting is disabled for the ruleset, the owner cannot change the token.\n        if (!ruleset.allowSetCustomToken()) revert JBController_RulesetSetTokenNotAllowed();\n\n        TOKENS.setTokenFor({projectId: projectId, token: token});\n    }\n\n    /// @notice Set a project's metadata URI.\n    /// @dev This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to\n    /// `SET_PROJECT_URI`.\n    /// @param projectId The ID of the project to set the metadata URI of.\n    /// @param uri The metadata URI to set.\n    function setUriOf(uint256 projectId, string calldata uri) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_PROJECT_URI\n        });\n\n        // Set the project's metadata URI.\n        uriOf[projectId] = uri;\n\n        emit SetUri({projectId: projectId, uri: uri, caller: _msgSender()});\n    }\n\n    /// @notice Allows a credit holder to transfer credits to another address.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `TRANSFER_CREDITS`.\n    /// @param holder The address to transfer credits from.\n    /// @param projectId The ID of the project whose credits are being transferred.\n    /// @param recipient The address to transfer credits to.\n    /// @param creditCount The number of credits to transfer.\n    function transferCreditsFrom(\n        address holder,\n        uint256 projectId,\n        address recipient,\n        uint256 creditCount\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.TRANSFER_CREDITS});\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Credit transfers must not be paused.\n        if (ruleset.pauseCreditTransfers()) revert JBController_CreditTransfersPaused();\n\n        TOKENS.transferCreditsFrom({holder: holder, projectId: projectId, recipient: recipient, count: creditCount});\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Set up a project's terminals.\n    /// @param projectId The ID of the project to set up terminals for.\n    /// @param terminalConfigs The terminals to set up.\n    function _configureTerminals(uint256 projectId, JBTerminalConfig[] calldata terminalConfigs) internal {\n        // Initialize an array of terminals to populate.\n        IJBTerminal[] memory terminals = new IJBTerminal[](terminalConfigs.length);\n\n        for (uint256 i; i < terminalConfigs.length; i++) {\n            // Set the terminal configuration being iterated on.\n            JBTerminalConfig memory terminalConfig = terminalConfigs[i];\n\n            // Add the accounting contexts for the specified tokens.\n            terminalConfig.terminal.addAccountingContextsFor({\n                projectId: projectId,\n                accountingContexts: terminalConfig.accountingContextsToAccept\n            });\n\n            // Add the terminal.\n            terminals[i] = terminalConfig.terminal;\n        }\n\n        // Set the terminals in the directory.\n        if (terminalConfigs.length > 0) {\n            DIRECTORY.setTerminalsOf({projectId: projectId, terminals: terminals});\n        }\n    }\n\n    /// @notice Queues one or more rulesets and stores information pertinent to the configuration.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets being queued.\n    /// @return rulesetId The ID of the last ruleset that was successfully queued.\n    function _queueRulesets(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations\n    )\n        internal\n        returns (uint256 rulesetId)\n    {\n        for (uint256 i; i < rulesetConfigurations.length; i++) {\n            // Get a reference to the ruleset config being iterated on.\n            JBRulesetConfig memory rulesetConfig = rulesetConfigurations[i];\n\n            // Make sure its reserved percent is valid.\n            if (rulesetConfig.metadata.reservedPercent > JBConstants.MAX_RESERVED_PERCENT) {\n                revert JBController_InvalidReservedPercent(\n                    rulesetConfig.metadata.reservedPercent, JBConstants.MAX_RESERVED_PERCENT\n                );\n            }\n\n            // Make sure its cash out tax rate is valid.\n            if (rulesetConfig.metadata.cashOutTaxRate > JBConstants.MAX_CASH_OUT_TAX_RATE) {\n                revert JBController_InvalidCashOutTaxRate(\n                    rulesetConfig.metadata.cashOutTaxRate, JBConstants.MAX_CASH_OUT_TAX_RATE\n                );\n            }\n\n            // Queue its ruleset.\n            JBRuleset memory ruleset = RULESETS.queueFor({\n                projectId: projectId,\n                duration: rulesetConfig.duration,\n                weight: rulesetConfig.weight,\n                weightCutPercent: rulesetConfig.weightCutPercent,\n                approvalHook: rulesetConfig.approvalHook,\n                metadata: JBRulesetMetadataResolver.packRulesetMetadata(rulesetConfig.metadata),\n                mustStartAtOrAfter: rulesetConfig.mustStartAtOrAfter\n            });\n\n            // Set its split groups.\n            SPLITS.setSplitGroupsOf({\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                splitGroups: rulesetConfig.splitGroups\n            });\n\n            // Set its fund access limits.\n            FUND_ACCESS_LIMITS.setFundAccessLimitsFor({\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                fundAccessLimitGroups: rulesetConfig.fundAccessLimitGroups\n            });\n\n            // If this is the last configuration being queued, return the ruleset's ID.\n            if (i == rulesetConfigurations.length - 1) {\n                rulesetId = ruleset.id;\n            }\n        }\n    }\n\n    /// @notice Sends pending reserved tokens to the project's reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return tokenCount The amount of reserved tokens minted and sent.\n    function _sendReservedTokensToSplitsOf(uint256 projectId) internal returns (uint256 tokenCount) {\n        // Get a reference to the number of tokens that need to be minted.\n        tokenCount = pendingReservedTokenBalanceOf[projectId];\n\n        // Revert if there are no pending reserved tokens\n        if (tokenCount == 0) revert JBController_NoReservedTokens();\n\n        // Get the ruleset to read the reserved percent from.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Get a reference to the project's owner.\n        address owner = PROJECTS.ownerOf(projectId);\n\n        // Reset the pending reserved token balance.\n        pendingReservedTokenBalanceOf[projectId] = 0;\n\n        // Mint the tokens to this contract.\n        IJBToken token = TOKENS.mintFor({holder: address(this), projectId: projectId, count: tokenCount});\n\n        // Send reserved tokens to splits and get a reference to the amount left after the splits have all been paid.\n        uint256 leftoverTokenCount = tokenCount == 0\n            ? 0\n            : _sendReservedTokensToSplitGroupOf({\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                groupId: JBSplitGroupIds.RESERVED_TOKENS,\n                tokenCount: tokenCount,\n                token: token\n            });\n\n        // Mint any leftover tokens to the project owner.\n        if (leftoverTokenCount > 0) {\n            _sendTokens({projectId: projectId, tokenCount: leftoverTokenCount, recipient: owner, token: token});\n        }\n\n        emit SendReservedTokensToSplits({\n            rulesetId: ruleset.id,\n            rulesetCycleNumber: ruleset.cycleNumber,\n            projectId: projectId,\n            owner: owner,\n            tokenCount: tokenCount,\n            leftoverAmount: leftoverTokenCount,\n            caller: _msgSender()\n        });\n    }\n\n    /// @notice Send project tokens to a split group.\n    /// @dev This is used to send reserved tokens to the reserved token split group.\n    /// @param projectId The ID of the project the splits belong to.\n    /// @param rulesetId The ID of the split group's ruleset.\n    /// @param groupId The ID of the split group.\n    /// @param tokenCount The number of tokens to send.\n    /// @param token The token to send.\n    /// @return leftoverTokenCount If the split percents don't add up to 100%, the leftover amount is returned.\n    function _sendReservedTokensToSplitGroupOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId,\n        uint256 tokenCount,\n        IJBToken token\n    )\n        internal\n        returns (uint256 leftoverTokenCount)\n    {\n        // Set the leftover amount to the initial amount.\n        leftoverTokenCount = tokenCount;\n\n        // Get a reference to the split group.\n        JBSplit[] memory splits = SPLITS.splitsOf({projectId: projectId, rulesetId: rulesetId, groupId: groupId});\n\n        // Keep a reference to the number of splits being iterated on.\n        uint256 numberOfSplits = splits.length;\n\n        // Send the tokens to the splits.\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Get a reference to the split being iterated on.\n            JBSplit memory split = splits[i];\n\n            // Calculate the amount to send to the split.\n            uint256 splitTokenCount = mulDiv(tokenCount, split.percent, JBConstants.SPLITS_TOTAL_PERCENT);\n\n            // Mints tokens for the split if needed.\n            if (splitTokenCount > 0) {\n                // 1. If the split has a `hook`, call the hook's `processSplitWith` function.\n                // 2. Otherwise, if the split has a `projectId`, try to pay the project using the split's `beneficiary`,\n                // or the `_msgSender()` if the split has no beneficiary.\n                // 3. Otherwise, if the split has a beneficiary, send the tokens to the split's beneficiary.\n                // 4. Otherwise, send the tokens to the `_msgSender()`.\n\n                // If the split has a hook, call its `processSplitWith` function.\n                if (split.hook != IJBSplitHook(address(0))) {\n                    // Send the tokens to the split hook.\n                    // slither-disable-next-line reentrancy-events\n                    _sendTokens({\n                        projectId: projectId,\n                        tokenCount: splitTokenCount,\n                        recipient: address(split.hook),\n                        token: token\n                    });\n\n                    // slither-disable-next-line reentrancy-events\n                    split.hook.processSplitWith(\n                        JBSplitHookContext({\n                            token: address(token),\n                            amount: splitTokenCount,\n                            decimals: 18, // Hard-coded in `JBTokens`.\n                            projectId: projectId,\n                            groupId: groupId,\n                            split: split\n                        })\n                    );\n                    // If the split has a project ID, try to pay the project. If that fails, pay the beneficiary.\n                } else {\n                    // Pay the project using the split's beneficiary if one was provided. Otherwise, use the message\n                    // sender.\n                    address beneficiary = split.beneficiary != address(0) ? split.beneficiary : _msgSender();\n\n                    if (split.projectId != 0) {\n                        // Get a reference to the receiving project's primary payment terminal for the token.\n                        IJBTerminal terminal = token == IJBToken(address(0))\n                            ? IJBTerminal(address(0))\n                            : DIRECTORY.primaryTerminalOf({projectId: split.projectId, token: address(token)});\n\n                        // If the project doesn't have a token, or if the receiving project doesn't have a terminal\n                        // which accepts the token, send the tokens to the beneficiary.\n                        if (address(token) == address(0) || address(terminal) == address(0)) {\n                            // Mint the tokens to the beneficiary.\n                            // slither-disable-next-line reentrancy-events\n                            _sendTokens({\n                                projectId: projectId,\n                                tokenCount: splitTokenCount,\n                                recipient: beneficiary,\n                                token: token\n                            });\n                        } else {\n                            // Use the `projectId` in the pay metadata.\n                            // slither-disable-next-line reentrancy-events\n                            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n                            // Try to fulfill the payment.\n                            try this.executePayReservedTokenToTerminal({\n                                projectId: split.projectId,\n                                terminal: terminal,\n                                token: token,\n                                splitTokenCount: splitTokenCount,\n                                beneficiary: beneficiary,\n                                metadata: metadata\n                            }) {} catch (bytes memory reason) {\n                                emit ReservedDistributionReverted({\n                                    projectId: projectId,\n                                    split: split,\n                                    tokenCount: splitTokenCount,\n                                    reason: reason,\n                                    caller: _msgSender()\n                                });\n\n                                // If it fails, transfer the tokens from this contract to the beneficiary.\n                                IERC20(address(token)).safeTransfer(beneficiary, splitTokenCount);\n                            }\n                        }\n                    } else if (beneficiary == address(0xdead)) {\n                        // If the split has no project ID, and the beneficiary is 0xdead, burn.\n                        TOKENS.burnFrom({holder: address(this), projectId: projectId, count: splitTokenCount});\n                    } else {\n                        // If the split has no project Id, send to beneficiary.\n                        _sendTokens({\n                            projectId: projectId,\n                            tokenCount: splitTokenCount,\n                            recipient: beneficiary,\n                            token: token\n                        });\n                    }\n                }\n\n                // Subtract the amount sent from the leftover.\n                leftoverTokenCount -= splitTokenCount;\n            }\n\n            emit SendReservedTokensToSplit({\n                projectId: projectId,\n                rulesetId: rulesetId,\n                groupId: groupId,\n                split: split,\n                tokenCount: splitTokenCount,\n                caller: _msgSender()\n            });\n        }\n    }\n\n    /// @notice Send tokens from this contract to a recipient.\n    /// @param projectId The ID of the project the tokens belong to.\n    /// @param tokenCount The number of tokens to send.\n    /// @param recipient The address to send the tokens to.\n    /// @param token The token to send, if one exists\n    function _sendTokens(uint256 projectId, uint256 tokenCount, address recipient, IJBToken token) internal {\n        if (token != IJBToken(address(0))) {\n            IERC20(address(token)).safeTransfer({to: recipient, value: tokenCount});\n        } else {\n            TOKENS.transferCreditsFrom({\n                holder: address(this),\n                projectId: projectId,\n                recipient: recipient,\n                count: tokenCount\n            });\n        }\n    }\n}\n"},"src/structs/JBPermissionsData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint64 projectId;\n    uint8[] permissionIds;\n}\n"},"src/structs/JBCashOutHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutHook} from \"../interfaces/IJBCashOutHook.sol\";\n\n/// @notice A cash out hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The cash out hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBCashOutHookSpecification {\n    IJBCashOutHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/interfaces/IJBPermissioned.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"},"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"},"src/interfaces/IJBFundAccessLimits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"},"src/interfaces/IJBProjectUriRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"},"src/interfaces/IJBCashOutHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterCashOutRecordedContext} from \"./../structs/JBAfterCashOutRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `cashOutTokensOf(...)` logic completes (if passed by the ruleset's data\n/// hook).\ninterface IJBCashOutHook is IERC165 {\n    /// @notice This function is called by the terminal's `cashOutTokensOf(...)` function after the cash out has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterCashOutRecordedContext` struct.\n    function afterCashOutRecordedWith(JBAfterCashOutRecordedContext calldata context) external payable;\n}\n"},"src/libraries/JBSplitGroupIds.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Group IDs that categorize splits.\nlibrary JBSplitGroupIds {\n    uint256 public constant RESERVED_TOKENS = 1;\n}\n"},"src/interfaces/IJBDirectory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"},"src/interfaces/IJBProjects.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"},"src/structs/JBRuleset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"},"src/structs/JBCurrencyAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"},"src/interfaces/IJBRulesetDataHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeCashOutRecordedContext} from \"./../structs/JBBeforeCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"./../structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/cashout functionality by overriding the weight or memo. They can\n/// also specify pay/cashout hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForCashOut` enabled, its `dataHook` is called by\n/// the terminal upon payments/cashouts (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param ruleset The ruleset to check the token minting permission of.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(\n        uint256 projectId,\n        JBRuleset memory ruleset,\n        address addr\n    )\n        external\n        view\n        returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a cash out is recorded in the terminal store. This data is provided to the\n    /// terminal's `cashOutTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `cashOutTokensOf(...)` function as a\n    /// `JBBeforeCashOutRecordedContext` struct.\n    /// @return cashOutTaxRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return cashOutCount The amount of tokens that should be considered cashed out.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to cash out hooks instead of returning to the\n    /// beneficiary.\n    function beforeCashOutRecordedWith(JBBeforeCashOutRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 cashOutTaxRate,\n            uint256 cashOutCount,\n            uint256 totalSupply,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        );\n}\n"},"src/structs/JBPayHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/structs/JBTerminalConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"},"src/interfaces/IJBToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function canBeAddedTo(uint256 projectId) external view returns (bool);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"},"src/structs/JBTokenAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"},"src/interfaces/IJBPriceFeed.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"},"node_modules/@prb/math/src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*ydenominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"},"src/structs/JBAfterCashOutRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project being cashed out from.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of project tokens being cashed out.\n/// @custom:member cashOutTaxRate The current ruleset's cash out tax rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the cash out hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the cash out hook.\n/// @custom:member cashOutMetadata Extra data specified by the account cashing out, which is sent to the cash out hook.\nstruct JBAfterCashOutRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 cashOutTaxRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes cashOutMetadata;\n}\n"},"src/interfaces/IJBRulesetApprovalHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) external view returns (JBApprovalStatus);\n}\n"},"src/abstract/JBPermissioned.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"},"src/interfaces/IJBController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event DeployERC20(\n        uint256 indexed projectId, address indexed deployer, bytes32 salt, bytes32 saltHash, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n    function OMNICHAIN_RULESET_OPERATOR() external view returns (address);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"},"src/structs/JBAfterPayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"},"src/interfaces/IJBSplits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"},"src/structs/JBSplitHookContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"},"src/interfaces/IJBSplitHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"src/interfaces/IJBMigratable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IJBMigratable is IERC165 {\n    event Migrate(uint256 indexed projectId, IERC165 to, address caller);\n\n    function migrate(uint256 projectId, IERC165 to) external;\n    function beforeReceiveMigrationFrom(IERC165 from, uint256 projectId) external;\n}\n"},"src/structs/JBSplitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"src/interfaces/IJBPayHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"},"src/structs/JBAccountingContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"},"src/interfaces/IJBTokens.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool tokensWereClaimed, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external returns (IJBToken token);\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"},"src/structs/JBSplit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    uint32 percent;\n    uint64 projectId;\n    address payable beneficiary;\n    bool preferAddToBalance;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"},"src/structs/JBRulesetWithMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"},"src/structs/JBRulesetConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a cut `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"},"src/libraries/JBConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"},"node_modules/@bananapus/permission-ids-v5/src/JBPermissionIds.sol":{"content":"// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant CASH_OUT_TOKENS = 3; // Permission to call `JBMultiTerminal.cashOutTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n    uint8 internal constant SUCKER_SAFETY = 30; // Permission to call `BPSucker.enableEmergencyHatchFor` and\n        // `BPSucker.setDeprecation`.\n}\n"},"src/structs/JBRulesetMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOuts A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForCashOut A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, only the 14 least significant bits can be used, the 2 most\n/// significant bits are disregarded.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForPay;\n    bool useDataHookForCashOut;\n    address dataHook;\n    uint16 metadata;\n}\n"},"src/interfaces/IJBRulesets.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"},"src/interfaces/IJBTokenUriResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"node_modules/@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"src/interfaces/IJBPermissions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"},"src/structs/JBFundAccessLimitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"},"src/interfaces/IJBDirectoryAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"evmVersion":"paris","metadata":{"appendCBOR":true,"bytecodeHash":"ipfs","useLiteralContent":false},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/","@arbitrum/=node_modules/@arbitrum/","@bananapus/=node_modules/@bananapus/","@chainlink/=node_modules/@chainlink/","@eth-optimism/=node_modules/@eth-optimism/","@offchainlabs/=node_modules/@offchainlabs/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@scroll-tech/=node_modules/@scroll-tech/","@uniswap/=node_modules/@uniswap/","@zksync/=node_modules/@zksync/","forge-std/=lib/forge-std/src/","hardhat/=node_modules/hardhat/","solmate/=node_modules/solmate/","sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"],"viaIR":false}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"directory\",\"type\":\"address\"},{\"internalType\":\"contract IJBFundAccessLimits\",\"name\":\"fundAccessLimits\",\"type\":\"address\"},{\"internalType\":\"contract IJBPermissions\",\"name\":\"permissions\",\"type\":\"address\"},{\"internalType\":\"contract IJBPrices\",\"name\":\"prices\",\"type\":\"address\"},{\"internalType\":\"contract IJBProjects\",\"name\":\"projects\",\"type\":\"address\"},{\"internalType\":\"contract IJBRulesets\",\"name\":\"rulesets\",\"type\":\"address\"},{\"internalType\":\"contract IJBSplits\",\"name\":\"splits\",\"type\":\"address\"},{\"internalType\":\"contract IJBTokens\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"omnichainRulesetOperator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"JBController_AddingPriceFeedNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_CreditTransfersPaused\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBController_InvalidCashOutTaxRate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBController_InvalidReservedPercent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_MintNotAllowedAndNotTerminalOrHook\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_NoReservedTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"contract IJBDirectory\",\"name\":\"directory\",\"type\":\"address\"}],\"name\":\"JBController_OnlyDirectory\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingReservedTokenBalance\",\"type\":\"uint256\"}],\"name\":\"JBController_PendingReservedTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_RulesetSetTokenNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_RulesetsAlreadyLaunched\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_RulesetsArrayEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_ZeroTokensToBurn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBController_ZeroTokensToMint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permissionId\",\"type\":\"uint256\"}],\"name\":\"JBPermissioned_Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"BurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"saltHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"DeployERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"projectUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LaunchProject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LaunchRulesets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"contract IERC165\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"beneficiaryTokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservedPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"PrepMigration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"QueueRulesets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct JBSplit\",\"name\":\"split\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ReservedDistributionReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct JBSplit\",\"name\":\"split\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SendReservedTokensToSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leftoverAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SendReservedTokensToSplits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SetUri\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DIRECTORY\",\"outputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FUND_ACCESS_LIMITS\",\"outputs\":[{\"internalType\":\"contract IJBFundAccessLimits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OMNICHAIN_RULESET_OPERATOR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSIONS\",\"outputs\":[{\"internalType\":\"contract IJBPermissions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICES\",\"outputs\":[{\"internalType\":\"contract IJBPrices\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECTS\",\"outputs\":[{\"internalType\":\"contract IJBProjects\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RULESETS\",\"outputs\":[{\"internalType\":\"contract IJBRulesets\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SPLITS\",\"outputs\":[{\"internalType\":\"contract IJBSplits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENS\",\"outputs\":[{\"internalType\":\"contract IJBTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricingCurrency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitCurrency\",\"type\":\"uint256\"},{\"internalType\":\"contract IJBPriceFeed\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"addPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"allRulesetsOf\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"internalType\":\"struct JBRulesetWithMetadata[]\",\"name\":\"rulesets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC165\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"beforeReceiveMigrationFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"burnTokensOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"claimTokensFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"currentRulesetOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deployERC20For\",\"outputs\":[{\"internalType\":\"contract IJBToken\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IJBTerminal\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"contract IJBToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"splitTokenCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"executePayReservedTokenToTerminal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"}],\"name\":\"getRulesetOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"latestQueuedRulesetOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"internalType\":\"enum JBApprovalStatus\",\"name\":\"approvalStatus\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"projectUri\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"internalType\":\"struct JBSplit[]\",\"name\":\"splits\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBSplitGroup[]\",\"name\":\"splitGroups\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"payoutLimits\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"surplusAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBFundAccessLimitGroup[]\",\"name\":\"fundAccessLimitGroups\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBRulesetConfig[]\",\"name\":\"rulesetConfigurations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IJBTerminal\",\"name\":\"terminal\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContextsToAccept\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBTerminalConfig[]\",\"name\":\"terminalConfigurations\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"launchProjectFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"internalType\":\"struct JBSplit[]\",\"name\":\"splits\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBSplitGroup[]\",\"name\":\"splitGroups\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"payoutLimits\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"surplusAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBFundAccessLimitGroup[]\",\"name\":\"fundAccessLimitGroups\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBRulesetConfig[]\",\"name\":\"rulesetConfigurations\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IJBTerminal\",\"name\":\"terminal\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContextsToAccept\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBTerminalConfig[]\",\"name\":\"terminalConfigurations\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"launchRulesetsFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC165\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"useReservedPercent\",\"type\":\"bool\"}],\"name\":\"mintTokensOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"beneficiaryTokenCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"pendingReservedTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"mustStartAtOrAfter\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"internalType\":\"struct JBSplit[]\",\"name\":\"splits\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBSplitGroup[]\",\"name\":\"splitGroups\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"terminal\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"payoutLimits\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint224\",\"name\":\"amount\",\"type\":\"uint224\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBCurrencyAmount[]\",\"name\":\"surplusAllowances\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBFundAccessLimitGroup[]\",\"name\":\"fundAccessLimitGroups\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBRulesetConfig[]\",\"name\":\"rulesetConfigurations\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"queueRulesetsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"sendReservedTokensToSplitsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"setControllerAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"groupId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"internalType\":\"struct JBSplit[]\",\"name\":\"splits\",\"type\":\"tuple[]\"}],\"internalType\":\"struct JBSplitGroup[]\",\"name\":\"splitGroups\",\"type\":\"tuple[]\"}],\"name\":\"setSplitGroupsOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"setTerminalsAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"contract IJBToken\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setTokenFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setUriOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"totalTokenSupplyWithReservedTokensOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"creditCount\",\"type\":\"uint256\"}],\"name\":\"transferCreditsFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"upcomingRulesetOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"cycleNumber\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"id\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"basedOnId\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"weight\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"weightCutPercent\",\"type\":\"uint32\"},{\"internalType\":\"contract IJBRulesetApprovalHook\",\"name\":\"approvalHook\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"metadata\",\"type\":\"uint256\"}],\"internalType\":\"struct JBRuleset\",\"name\":\"ruleset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"reservedPercent\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"cashOutTaxRate\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"baseCurrency\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"pausePay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pauseCreditTransfers\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowOwnerMinting\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetCustomToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowTerminalMigration\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetTerminals\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowSetController\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddAccountingContext\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"allowAddPriceFeed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ownerMustSendPayouts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"holdFees\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useTotalSurplusForCashOuts\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForPay\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"useDataHookForCashOut\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"dataHook\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"metadata\",\"type\":\"uint16\"}],\"internalType\":\"struct JBRulesetMetadata\",\"name\":\"metadata\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"uriOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"JBController","CompilerVersion":"v0.8.23+commit.f704f362","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000000061e516886a0540f63157f112c0588ee0651dcf0000000000000000000000003a46b21720c8b70184b0434a2293b2fdcc497ce700000000000000000000000004fd6913d6c32d8c216e153a43c04b1857a7793d0000000000000000000000009b90e507cf6b7eb681a506b111f6f50245e614c4000000000000000000000000885f707efa18d2cb12f05a3a8eba6b4b26c8c1d40000000000000000000000006292281d69c3593fcf6ea074e5797341476ab4280000000000000000000000007160a322fea44945a6ef9adfd65c322258df3c5e0000000000000000000000004d0edd347fb1fa21589c1e109b3474924be876360000000000000000000000008f5ded85c40b50d223269c1f922a056e72101590000000000000000000000000c29d6995ab3b0df4650ad643adeac55e7acbb566","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}