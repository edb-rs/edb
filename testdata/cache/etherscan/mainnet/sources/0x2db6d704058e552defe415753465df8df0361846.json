{"expiry":6055833346,"data":[{"SourceCode":{"language":"Solidity","sources":{"node_modules/@openzeppelin/contracts/interfaces/IERC1363.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"},"src/interfaces/IJBProjectUriRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata uri) external;\n}\n"},"src/interfaces/IJBSplits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"},"src/structs/JBAfterCashOutRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being cashed out.\n/// @custom:member projectId The ID of the project being cashed out from.\n/// @custom:member rulesetId The ID of the ruleset the cash out is being made during.\n/// @custom:member cashOutCount The number of project tokens being cashed out.\n/// @custom:member cashOutTaxRate The current ruleset's cash out tax rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the cash out hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the cash out hook.\n/// @custom:member cashOutMetadata Extra data specified by the account cashing out, which is sent to the cash out hook.\nstruct JBAfterCashOutRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 cashOutCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 cashOutTaxRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes cashOutMetadata;\n}\n"},"src/interfaces/IJBPrices.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId,\n        uint256 indexed pricingCurrency,\n        uint256 indexed unitCurrency,\n        IJBPriceFeed feed,\n        address caller\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"},"src/structs/JBAccountingContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"},"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"src/JBMultiTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids-v5/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {IJBCashOutTerminal} from \"./interfaces/IJBCashOutTerminal.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBFeelessAddresses} from \"./interfaces/IJBFeelessAddresses.sol\";\nimport {IJBFeeTerminal} from \"./interfaces/IJBFeeTerminal.sol\";\nimport {IJBMultiTerminal} from \"./interfaces/IJBMultiTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./interfaces/IJBPayoutTerminal.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBPermitTerminal} from \"./interfaces/IJBPermitTerminal.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {IJBTokens} from \"./interfaces/IJBTokens.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBFees} from \"./libraries/JBFees.sol\";\nimport {JBMetadataResolver} from \"./libraries/JBMetadataResolver.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"./structs/JBAfterPayRecordedContext.sol\";\nimport {JBAfterCashOutRecordedContext} from \"./structs/JBAfterCashOutRecordedContext.sol\";\nimport {JBCashOutHookSpecification} from \"./structs/JBCashOutHookSpecification.sol\";\nimport {JBFee} from \"./structs/JBFee.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBSingleAllowance} from \"./structs/JBSingleAllowance.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice `JBMultiTerminal` manages native/ERC-20 payments, cash outs, and surplus allowance usage for any number of\n/// projects. Terminals are the entry point for operations involving inflows and outflows of funds.\ncontract JBMultiTerminal is JBPermissioned, ERC2771Context, IJBMultiTerminal {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error JBMultiTerminal_AccountingContextAlreadySet(address token);\n    error JBMultiTerminal_AddingAccountingContextNotAllowed();\n    error JBMultiTerminal_FeeTerminalNotFound();\n    error JBMultiTerminal_NoMsgValueAllowed(uint256 value);\n    error JBMultiTerminal_OverflowAlert(uint256 value, uint256 limit);\n    error JBMultiTerminal_PermitAllowanceNotEnough(uint256 amount, uint256 allowance);\n    error JBMultiTerminal_RecipientProjectTerminalNotFound(uint256 projectId, address token);\n    error JBMultiTerminal_SplitHookInvalid(IJBSplitHook hook);\n    error JBMultiTerminal_TerminalTokensIncompatible();\n    error JBMultiTerminal_TokenNotAccepted(address token);\n    error JBMultiTerminal_UnderMinReturnedTokens(uint256 count, uint256 min);\n    error JBMultiTerminal_UnderMinTokensPaidOut(uint256 amount, uint256 min);\n    error JBMultiTerminal_UnderMinTokensReclaimed(uint256 amount, uint256 min);\n    error JBMultiTerminal_ZeroAccountingContextDecimals();\n    error JBMultiTerminal_ZeroAccountingContextCurrency();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice This terminal's fee (as a fraction out of `JBConstants.MAX_FEE`).\n    /// @dev Fees are charged on payouts to addresses and surplus allowance usage, as well as cash outs while the\n    /// cash out tax rate is less than 100%.\n    uint256 public constant override FEE = 25; // 2.5%\n\n    //*********************************************************************//\n    // ------------------------ internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Project ID #1 receives fees. It should be the first project launched during the deployment process.\n    uint256 internal constant _FEE_BENEFICIARY_PROJECT_ID = 1;\n\n    /// @notice The number of seconds fees can be held for.\n    uint256 internal constant _FEE_HOLDING_SECONDS = 2_419_200; // 28 days\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for PROJECTS.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract that stores addresses that shouldn't incur fees when being paid towards or from.\n    IJBFeelessAddresses public immutable override FEELESS_ADDRESSES;\n\n    /// @notice The permit2 utility.\n    IPermit2 public immutable override PERMIT2;\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice The contract that stores and manages the terminal's data.\n    IJBTerminalStore public immutable override STORE;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBTokens public immutable override TOKENS;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Context describing how a token is accounted for by a project.\n    /// @custom:param projectId The ID of the project that the token accounting context applies to.\n    /// @custom:param token The address of the token being accounted for.\n    mapping(uint256 projectId => mapping(address token => JBAccountingContext)) internal _accountingContextForTokenOf;\n\n    /// @notice A list of tokens accepted by each project.\n    /// @custom:param projectId The ID of the project to get a list of accepted tokens for.\n    mapping(uint256 projectId => JBAccountingContext[]) internal _accountingContextsOf;\n\n    /// @notice Fees that are being held for each project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @custom:param projectId The ID of the project that is holding fees.\n    /// @custom:param token The token that the fees are held in.\n    mapping(uint256 projectId => mapping(address token => JBFee[])) internal _heldFeesOf;\n\n    /// @notice The next index to use when processing a next held fee.\n    /// @custom:param projectId The ID of the project that is holding fees.\n    /// @custom:param token The token that the fees are held in.\n    mapping(uint256 projectId => mapping(address token => uint256)) internal _nextHeldFeeIndexOf;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param feelessAddresses A contract that stores addresses that shouldn't incur fees when being paid towards or\n    /// from.\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param splits A contract that stores splits for each project.\n    /// @param store A contract that stores the terminal's data.\n    /// @param permit2 A permit2 utility.\n    /// @param trustedForwarder A trusted forwarder of transactions to this contract.\n    constructor(\n        IJBFeelessAddresses feelessAddresses,\n        IJBPermissions permissions,\n        IJBProjects projects,\n        IJBSplits splits,\n        IJBTerminalStore store,\n        IJBTokens tokens,\n        IPermit2 permit2,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        DIRECTORY = store.DIRECTORY();\n        FEELESS_ADDRESSES = feelessAddresses;\n        PROJECTS = projects;\n        RULESETS = store.RULESETS();\n        SPLITS = splits;\n        STORE = store;\n        TOKENS = tokens;\n        PERMIT2 = permit2;\n    }\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's accounting context for a token.\n    /// @dev See the `JBAccountingContext` struct for more information.\n    /// @param projectId The ID of the project to get token accounting context of.\n    /// @param token The token to check the accounting context of.\n    /// @return The token's accounting context for the token.\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        override\n        returns (JBAccountingContext memory)\n    {\n        return _accountingContextForTokenOf[projectId][token];\n    }\n\n    /// @notice The tokens accepted by a project.\n    /// @param projectId The ID of the project to get the accepted tokens of.\n    /// @return tokenContexts The accounting contexts of the accepted tokens.\n    function accountingContextsOf(uint256 projectId) external view override returns (JBAccountingContext[] memory) {\n        return _accountingContextsOf[projectId];\n    }\n\n    /// @notice Gets the total current surplus amount in this terminal for a project, in terms of a given currency.\n    /// @dev This total surplus only includes tokens that the project accepts (as returned by\n    /// `accountingContextsOf(...)`).\n    /// @param projectId The ID of the project to get the current total surplus of.\n    /// @param accountingContexts The accounting contexts to use to calculate the surplus. Pass an empty array to use\n    /// all of the project's accounting contexts.\n    /// @param decimals The number of decimals to include in the fixed point returned value.\n    /// @param currency The currency to express the returned value in terms of.\n    /// @return The current surplus amount the project has in this terminal, in terms of `currency` and with the\n    /// specified number of decimals.\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return STORE.currentSurplusOf({\n            terminal: address(this),\n            projectId: projectId,\n            accountingContexts: accountingContexts.length != 0 ? accountingContexts : _accountingContextsOf[projectId],\n            decimals: decimals,\n            currency: currency\n        });\n    }\n\n    /// @notice Fees that are being held for a project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @param projectId The ID of the project that is holding fees.\n    /// @param token The token that the fees are held in.\n    function heldFeesOf(\n        uint256 projectId,\n        address token,\n        uint256 count\n    )\n        external\n        view\n        override\n        returns (JBFee[] memory heldFees)\n    {\n        // Keep a reference to the start index.\n        uint256 startIndex = _nextHeldFeeIndexOf[projectId][token];\n\n        // Get a reference to the number of held fees.\n        uint256 numberOfHeldFees = _heldFeesOf[projectId][token].length;\n\n        // If the start index is greater than or equal to the number of held fees, return 0.\n        if (startIndex >= numberOfHeldFees) return new JBFee[](0);\n\n        // If the start index plus the count is greater than the number of fees, set the count to the number of fees\n        if (startIndex + count > numberOfHeldFees) count = numberOfHeldFees - startIndex;\n\n        // Create a new array to hold the fees.\n        heldFees = new JBFee[](count);\n\n        // Copy the fees into the array.\n        for (uint256 i; i < count; i++) {\n            heldFees[i] = _heldFeesOf[projectId][token][startIndex + i];\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBPermissioned).interfaceId\n            || interfaceId == type(IJBTerminal).interfaceId || interfaceId == type(IJBCashOutTerminal).interfaceId\n            || interfaceId == type(IJBPayoutTerminal).interfaceId || interfaceId == type(IJBPermitTerminal).interfaceId\n            || interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBFeeTerminal).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks this terminal's balance of a specific token.\n    /// @param token The address of the token to get this terminal's balance of.\n    /// @return This terminal's balance.\n    function _balanceOf(address token) internal view returns (uint256) {\n        // If the `token` is native, get the native token balance.\n        return token == JBConstants.NATIVE_TOKEN ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    /// @notice Returns the current controller of a project.\n    /// @param projectId The ID of the project to get the controller of.\n    /// @return controller The project's controller.\n    function _controllerOf(uint256 projectId) internal view returns (IJBController) {\n        return IJBController(address(DIRECTORY.controllerOf(projectId)));\n    }\n\n    /// @notice Returns a flag indicating if interacting with an address should not incur fees.\n    /// @param addr The address to check.\n    /// @return A flag indicating if the address should not incur fees.\n    function _isFeeless(address addr) internal view returns (bool) {\n        return FEELESS_ADDRESSES.isFeeless(addr);\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The owner of a project.\n    /// @param projectId The ID of the project to get the owner of.\n    /// @return The owner of the project.\n    function _ownerOf(uint256 projectId) internal view returns (address) {\n        return PROJECTS.ownerOf(projectId);\n    }\n\n    /// @notice The primary terminal of a project for a token.\n    /// @param projectId The ID of the project to get the primary terminal of.\n    /// @param token The token to get the primary terminal of.\n    /// @return The primary terminal of the project for the token.\n    function _primaryTerminalOf(uint256 projectId, address token) internal view returns (IJBTerminal) {\n        return DIRECTORY.primaryTerminalOf({projectId: projectId, token: token});\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Adds accounting contexts for a project to this terminal so the project can begin accepting the tokens in\n    /// those contexts.\n    /// @dev Only a project's owner, an operator with the `ADD_ACCOUNTING_CONTEXTS` permission from that owner, or a\n    /// project's controller can add accounting contexts for the project.\n    /// @param projectId The ID of the project having to add accounting contexts for.\n    /// @param accountingContexts The accounting contexts to add.\n    function addAccountingContextsFor(\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: _ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.ADD_ACCOUNTING_CONTEXTS,\n            alsoGrantAccessIf: _msgSender() == address(_controllerOf(projectId))\n        });\n\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Make sure that if there's a ruleset, it allows adding accounting contexts.\n        if (ruleset.id != 0 && !ruleset.allowAddAccountingContext()) {\n            revert JBMultiTerminal_AddingAccountingContextNotAllowed();\n        }\n\n        // Start accepting each token.\n        for (uint256 i; i < accountingContexts.length; i++) {\n            // Set the accounting context being iterated on.\n            JBAccountingContext memory accountingContext = accountingContexts[i];\n\n            // Get a storage reference to the currency accounting context for the token.\n            JBAccountingContext storage storedAccountingContext =\n                _accountingContextForTokenOf[projectId][accountingContext.token];\n\n            // Make sure the token accounting context isn't already set.\n            if (storedAccountingContext.token != address(0)) {\n                revert JBMultiTerminal_AccountingContextAlreadySet(storedAccountingContext.token);\n            }\n\n            // Keep track of a flag indiciating if we know the provided decimals are incorrect.\n            bool knownInvalidDecimals;\n\n            // Check if the token is the native token and has the correct decimals\n            if (accountingContext.token == JBConstants.NATIVE_TOKEN && accountingContext.decimals != 18) {\n                knownInvalidDecimals = true;\n            } else if (accountingContext.token != JBConstants.NATIVE_TOKEN) {\n                // slither-disable-next-line calls-loop\n                try IERC20Metadata(accountingContext.token).decimals() returns (uint8 decimals) {\n                    // slither-disable-next-line calls-loop\n                    if (accountingContext.decimals != decimals) {\n                        knownInvalidDecimals = true;\n                    }\n                } catch {\n                    // The token didn't support `decimals`.\n                    knownInvalidDecimals = false;\n                }\n            }\n\n            // Make sure the decimals are correct.\n            if (knownInvalidDecimals) {\n                revert JBMultiTerminal_ZeroAccountingContextDecimals();\n            }\n\n            // Make sure the currency is non-zero.\n            if (accountingContext.currency == 0) revert JBMultiTerminal_ZeroAccountingContextCurrency();\n\n            // Define the context from the config.\n            storedAccountingContext.token = accountingContext.token;\n            storedAccountingContext.decimals = accountingContext.decimals;\n            storedAccountingContext.currency = accountingContext.currency;\n\n            // Add the token to the list of accepted tokens of the project.\n            _accountingContextsOf[projectId].push(storedAccountingContext);\n\n            emit SetAccountingContext({projectId: projectId, context: storedAccountingContext, caller: _msgSender()});\n        }\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @dev Adding to balance can unlock held fees if `shouldUnlockHeldFees` is true.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param amount The amount of tokens to add to the balance, as a fixed point number with the same number of\n    /// decimals as this terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param token The token being added to the balance.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        override\n    {\n        // Add to balance.\n        _addToBalanceOf({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            shouldReturnHeldFees: shouldReturnHeldFees,\n            memo: memo,\n            metadata: metadata\n        });\n    }\n\n    /// @notice Holders can cash out a project's tokens to reclaim some of that project's surplus tokens, or to trigger\n    /// rules determined by the current ruleset's data hook and cash out hook.\n    /// @dev Only a token's holder or an operator with the `CASH_OUT_TOKENS` permission from that holder can cash out\n    /// those tokens.\n    /// @param holder The account whose tokens are being cashed out.\n    /// @param projectId The ID of the project the project tokens belong to.\n    /// @param cashOutCount The number of project tokens to cash out, as a fixed point number with 18 decimals.\n    /// @param tokenToReclaim The token being reclaimed.\n    /// @param minTokensReclaimed The minimum number of terminal tokens expected in return, as a fixed point number with\n    /// the same number of decimals as this terminal. If the amount of tokens minted for the beneficiary would be less\n    /// than this amount, the cash out is reverted.\n    /// @param beneficiary The address to send the cashed out terminal tokens to, and to pass along to the ruleset's\n    /// data hook and cash out hook if applicable.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and cash out hook if\n    /// applicable.\n    /// @return reclaimAmount The amount of terminal tokens that the project tokens were cashed out for, as a fixed\n    /// point\n    /// number with 18 decimals.\n    function cashOutTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        address tokenToReclaim,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        override\n        returns (uint256 reclaimAmount)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.CASH_OUT_TOKENS});\n\n        reclaimAmount = _cashOutTokensOf({\n            holder: holder,\n            projectId: projectId,\n            cashOutCount: cashOutCount,\n            tokenToReclaim: tokenToReclaim,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n\n        // The amount being reclaimed must be at least as much as was expected.\n        if (reclaimAmount < minTokensReclaimed) {\n            revert JBMultiTerminal_UnderMinTokensReclaimed(reclaimAmount, minTokensReclaimed);\n        }\n    }\n\n    /// @notice Executes a payout to a split.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split belongs to.\n    /// @param token The address of the token being paid to the split.\n    /// @param amount The total amount being paid to the split, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function executePayout(\n        JBSplit calldata split,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address originalMessageSender\n    )\n        external\n        returns (uint256 netPayoutAmount)\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        // By default, the net payout amount is the full amount. This will be adjusted if fees are taken.\n        netPayoutAmount = amount;\n\n        // If there's a split hook set, transfer to its `process` function.\n        if (split.hook != IJBSplitHook(address(0))) {\n            // Make sure that the address supports the split hook interface.\n            if (!split.hook.supportsInterface(type(IJBSplitHook).interfaceId)) {\n                revert JBMultiTerminal_SplitHookInvalid(split.hook);\n            }\n\n            // This payout is eligible for a fee since the funds are leaving this contract and the split hook isn't a\n            // feeless address.\n            if (!_isFeeless(address(split.hook))) {\n                netPayoutAmount -= JBFees.feeAmountFrom({amountBeforeFee: amount, feePercent: FEE});\n            }\n\n            // Create the context to send to the split hook.\n            JBSplitHookContext memory context = JBSplitHookContext({\n                token: token,\n                amount: netPayoutAmount,\n                decimals: _accountingContextForTokenOf[projectId][token].decimals,\n                projectId: projectId,\n                groupId: uint256(uint160(token)),\n                split: split\n            });\n\n            // Trigger any inherited pre-transfer logic.\n            // Get a reference to the amount being paid in `msg.value`.\n            uint256 payValue = _beforeTransferTo({to: address(split.hook), token: token, amount: netPayoutAmount});\n\n            // If this terminal's token is the native token, send it in `msg.value`.\n            split.hook.processSplitWith{value: payValue}(context);\n\n            // Otherwise, if a project is specified, make a payment to it.\n        } else if (split.projectId != 0) {\n            // Get a reference to the terminal being used.\n            IJBTerminal terminal = _primaryTerminalOf({projectId: split.projectId, token: token});\n\n            // The project must have a terminal to send funds to.\n            if (terminal == IJBTerminal(address(0))) {\n                revert JBMultiTerminal_RecipientProjectTerminalNotFound(split.projectId, token);\n            }\n\n            // This payout is eligible for a fee if the funds are leaving this contract and the receiving terminal isn't\n            // a feelss address.\n            if (terminal != this && !_isFeeless(address(terminal))) {\n                netPayoutAmount -= JBFees.feeAmountFrom({amountBeforeFee: amount, feePercent: FEE});\n            }\n\n            // Send the `projectId` in the metadata as a referral.\n            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n            // Add to balance if preferred.\n            if (split.preferAddToBalance) {\n                _efficientAddToBalance({\n                    terminal: terminal,\n                    projectId: split.projectId,\n                    token: token,\n                    amount: netPayoutAmount,\n                    metadata: metadata\n                });\n            } else {\n                // Keep a reference to the beneficiary of the payment.\n                address beneficiary = split.beneficiary != address(0) ? split.beneficiary : originalMessageSender;\n\n                _efficientPay({\n                    terminal: terminal,\n                    projectId: split.projectId,\n                    token: token,\n                    amount: netPayoutAmount,\n                    beneficiary: beneficiary,\n                    metadata: metadata\n                });\n            }\n        } else {\n            // If there's a beneficiary, send the funds directly to the beneficiary.\n            // If there isn't a beneficiary, send the funds to the  `_msgSender()`.\n            address payable recipient =\n                split.beneficiary != address(0) ? split.beneficiary : payable(originalMessageSender);\n\n            // This payout is eligible for a fee since the funds are leaving this contract and the recipient isn't a\n            // feeless address.\n            if (!_isFeeless(recipient)) {\n                netPayoutAmount -= JBFees.feeAmountFrom({amountBeforeFee: amount, feePercent: FEE});\n            }\n\n            // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the\n            // `_msgSender()`.\n            _transferFrom({from: address(this), to: recipient, token: token, amount: netPayoutAmount});\n        }\n    }\n\n    /// @notice Process a specified amount of fees for a project.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint tokens to (from the project which receives fees), and pass along to the\n    /// ruleset's data hook and pay hook if applicable.\n    /// @param feeTerminal The terminal that'll receive the fees.\n    function executeProcessFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal\n    )\n        external\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        if (address(feeTerminal) == address(0)) {\n            revert JBMultiTerminal_FeeTerminalNotFound();\n        }\n\n        // Send the projectId in the metadata.\n        bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n        _efficientPay({\n            terminal: feeTerminal,\n            projectId: _FEE_BENEFICIARY_PROJECT_ID,\n            token: token,\n            amount: amount,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n    }\n\n    /// @notice Transfer funds to an address.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param addr The address to transfer funds to.\n    /// @param token The token to transfer.\n    /// @param amount The amount of tokens to transfer.\n    function executeTransferTo(address payable addr, address token, uint256 amount) external {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        _transferFrom({from: address(this), to: addr, token: token, amount: amount});\n    }\n\n    /// @notice Migrate a project's funds and operations to a new terminal that accepts the same token type.\n    /// @dev Only a project's owner or an operator with the `MIGRATE_TERMINAL` permission from that owner can migrate\n    /// the project's terminal.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The address of the token being migrated.\n    /// @param to The terminal contract being migrated to, which will receive the project's funds and operations.\n    /// @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals\n    /// as this terminal.\n    function migrateBalanceOf(\n        uint256 projectId,\n        address token,\n        IJBTerminal to\n    )\n        external\n        override\n        returns (uint256 balance)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: _ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MIGRATE_TERMINAL\n        });\n\n        // The terminal being migrated to must accept the same token as this terminal.\n        if (to.accountingContextForTokenOf({projectId: projectId, token: token}).currency == 0) {\n            revert JBMultiTerminal_TerminalTokensIncompatible();\n        }\n\n        // Record the migration in the store.\n        // slither-disable-next-line reentrancy-events\n        balance = STORE.recordTerminalMigration({projectId: projectId, token: token});\n\n        emit MigrateTerminal({projectId: projectId, token: token, to: to, amount: balance, caller: _msgSender()});\n\n        // Transfer the balance if needed.\n        if (balance != 0) {\n            // Trigger any inherited pre-transfer logic.\n            // If this terminal's token is the native token, send it in `msg.value`.\n            // slither-disable-next-line reentrancy-events\n            uint256 payValue = _beforeTransferTo({to: address(to), token: token, amount: balance});\n\n            // Withdraw the balance to transfer to the new terminal;\n            // slither-disable-next-line reentrancy-events\n            to.addToBalanceOf{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: balance,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: bytes(\"\")\n            });\n        }\n    }\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is native, this is ignored and `msg.value` is used in its\n    /// place.\n    /// @param token The token being paid.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param minReturnedTokens The minimum number of project tokens expected in return for this payment, as a fixed\n    /// point number with the same number of decimals as this terminal. If the amount of tokens minted for the\n    /// beneficiary would be less than this amount, the payment is reverted.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to pass along to the emitted event, as well as the data hook and pay hook if applicable.\n    /// @return beneficiaryTokenCount The number of tokens minted to the beneficiary, as a fixed point number with 18\n    /// decimals.\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // Get a reference to the beneficiary's balance before the payment.\n        uint256 beneficiaryBalanceBefore = TOKENS.totalBalanceOf({holder: beneficiary, projectId: projectId});\n\n        // Pay the project.\n        _pay({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            payer: _msgSender(),\n            beneficiary: beneficiary,\n            memo: memo,\n            metadata: metadata\n        });\n\n        // Get a reference to the beneficiary's balance after the payment.\n        uint256 beneficiaryBalanceAfter = TOKENS.totalBalanceOf({holder: beneficiary, projectId: projectId});\n\n        // Set the beneficiary token count.\n        if (beneficiaryBalanceAfter > beneficiaryBalanceBefore) {\n            beneficiaryTokenCount = beneficiaryBalanceAfter - beneficiaryBalanceBefore;\n        }\n\n        // The token count for the beneficiary must be greater than or equal to the specified minimum.\n        if (beneficiaryTokenCount < minReturnedTokens) {\n            revert JBMultiTerminal_UnderMinReturnedTokens(beneficiaryTokenCount, minReturnedTokens);\n        }\n    }\n\n    /// @notice Process any fees that are being held for the project.\n    /// @param projectId The ID of the project to process held fees for.\n    /// @param token The token to process held fees for.\n    /// @param count The number of fees to process.\n    function processHeldFeesOf(uint256 projectId, address token, uint256 count) external override {\n        // Keep a reference to the start index.\n        uint256 startIndex = _nextHeldFeeIndexOf[projectId][token];\n\n        // Get a reference to the project's held fees.\n        uint256 numberOfHeldFees = _heldFeesOf[projectId][token].length;\n\n        // If the start index is greater than or equal to the number of held fees, return.\n        if (startIndex >= numberOfHeldFees) return;\n\n        // Keep a reference to the terminal that'll receive the fees.\n        IJBTerminal feeTerminal = _primaryTerminalOf({projectId: _FEE_BENEFICIARY_PROJECT_ID, token: token});\n\n        // Calculate the number of iterations to perform.\n        if (startIndex + count > numberOfHeldFees) count = numberOfHeldFees - startIndex;\n\n        // Process each fee.\n        for (uint256 i; i < count; i++) {\n            // Keep a reference to the held fee being iterated on.\n            JBFee memory heldFee = _heldFeesOf[projectId][token][startIndex + i];\n\n            // Can't process fees that aren't yet unlocked. Fees unlock sequentially in the array, so nothing left to do\n            // if the current fee isn't yet unlocked.\n            if (heldFee.unlockTimestamp > block.timestamp) {\n                // Restart at this index next time.\n                if (i > 0) _nextHeldFeeIndexOf[projectId][token] = startIndex + i;\n                return;\n            }\n\n            // Process the fee.\n            // slither-disable-next-line reentrancy-no-eth\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: JBFees.feeAmountFrom({amountBeforeFee: heldFee.amount, feePercent: FEE}),\n                beneficiary: heldFee.beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: true\n            });\n        }\n\n        // Restart at the next fee next time.\n        _nextHeldFeeIndexOf[projectId][token] = startIndex + count;\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @dev Payouts a projects don't incur fees if its terminal is feeless.\n    /// @param projectId The ID of the project having its payouts sent.\n    /// @param token The token being sent.\n    /// @param amount The total number of terminal tokens to send, as a fixed point number with same number of decimals\n    /// as this terminal.\n    /// @param currency The expected currency of the payouts being sent. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that the `amount` should be worth (if expressed\n    /// in terms of this terminal's currency), as a fixed point number with the same number of decimals as this\n    /// terminal. If the amount of tokens paid out would be less than this amount, the send is reverted.\n    /// @return amountPaidOut The total amount paid out.\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        override\n        returns (uint256 amountPaidOut)\n    {\n        amountPaidOut = _sendPayoutsOf({projectId: projectId, token: token, amount: amount, currency: currency});\n\n        // The amount being paid out must be at least as much as was expected.\n        if (amountPaidOut < minTokensPaidOut) {\n            revert JBMultiTerminal_UnderMinTokensPaidOut(amountPaidOut, minTokensPaidOut);\n        }\n    }\n\n    /// @notice Allows a project to pay out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that should be returned from the surplus allowance\n    /// (excluding fees), as a fixed point number with 18 decimals. If the amount of surplus used would be less than\n    /// this amount, the transaction is reverted.\n    /// @param beneficiary The address to send the surplus funds to.\n    /// @param feeBeneficiary The address to send the tokens resulting from paying the fee.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return netAmountPaidOut The number of tokens that were sent to the beneficiary, as a fixed point number with\n    /// the same amount of decimals as the terminal.\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        address payable feeBeneficiary,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 netAmountPaidOut)\n    {\n        // Keep a reference to the project's owner.\n        address owner = _ownerOf(projectId);\n\n        // Enforce permissions.\n        _requirePermissionFrom({account: owner, projectId: projectId, permissionId: JBPermissionIds.USE_ALLOWANCE});\n\n        netAmountPaidOut = _useAllowanceOf({\n            projectId: projectId,\n            owner: owner,\n            token: token,\n            amount: amount,\n            currency: currency,\n            beneficiary: beneficiary,\n            feeBeneficiary: feeBeneficiary,\n            memo: memo\n        });\n\n        // The amount being withdrawn must be at least as much as was expected.\n        if (netAmountPaidOut < minTokensPaidOut) {\n            revert JBMultiTerminal_UnderMinTokensPaidOut(netAmountPaidOut, minTokensPaidOut);\n        }\n    }\n\n    //*********************************************************************//\n    // ------------------------ internal functions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Accepts an incoming token.\n    /// @param projectId The ID of the project that the transfer is being accepted for.\n    /// @param token The token being accepted.\n    /// @param amount The number of tokens being accepted.\n    /// @param metadata The metadata in which permit2 context is provided.\n    /// @return amount The number of tokens which have been accepted.\n    function _acceptFundsFor(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bytes calldata metadata\n    )\n        internal\n        returns (uint256)\n    {\n        // Make sure the project has an accounting context for the token being paid.\n        if (_accountingContextForTokenOf[projectId][token].token == address(0)) {\n            revert JBMultiTerminal_TokenNotAccepted(token);\n        }\n\n        // If the terminal's token is the native token, override `amount` with `msg.value`.\n        if (token == JBConstants.NATIVE_TOKEN) return msg.value;\n\n        // If the terminal's token is not native, revert if there is a non-zero `msg.value`.\n        if (msg.value != 0) revert JBMultiTerminal_NoMsgValueAllowed(msg.value);\n\n        // Unpack the allowance to use, if any, given by the frontend.\n        (bool exists, bytes memory parsedMetadata) =\n            JBMetadataResolver.getDataFor({id: JBMetadataResolver.getId(\"permit2\"), metadata: metadata});\n\n        // Check if the metadata contains permit data.\n        if (exists) {\n            // Keep a reference to the allowance context parsed from the metadata.\n            (JBSingleAllowance memory allowance) = abi.decode(parsedMetadata, (JBSingleAllowance));\n\n            // Make sure the permit allowance is enough for this payment. If not we revert early.\n            if (amount > allowance.amount) {\n                revert JBMultiTerminal_PermitAllowanceNotEnough(amount, allowance.amount);\n            }\n\n            // Keep a reference to the permit rules.\n            IAllowanceTransfer.PermitSingle memory permitSingle = IAllowanceTransfer.PermitSingle({\n                details: IAllowanceTransfer.PermitDetails({\n                    token: token,\n                    amount: allowance.amount,\n                    expiration: allowance.expiration,\n                    nonce: allowance.nonce\n                }),\n                spender: address(this),\n                sigDeadline: allowance.sigDeadline\n            });\n\n            // Set the allowance to `spend` tokens for the user.\n            try PERMIT2.permit({owner: _msgSender(), permitSingle: permitSingle, signature: allowance.signature}) {}\n                catch (bytes memory) {}\n        }\n\n        // Get a reference to the balance before receiving tokens.\n        uint256 balanceBefore = _balanceOf(token);\n\n        // Transfer tokens to this terminal from the msg sender.\n        _transferFrom({from: _msgSender(), to: payable(address(this)), token: token, amount: amount});\n\n        // The amount should reflect the change in balance.\n        return _balanceOf(token) - balanceBefore;\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param token The address of the token being added to the project's balance.\n    /// @param amount The amount of tokens to add as a fixed point number with the same number of decimals as this\n    /// terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function _addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Return held fees if desired. This mechanism means projects don't pay fees multiple times when funds go out of\n        // and back into the protocol.\n        uint256 returnedFees =\n            shouldReturnHeldFees ? _returnHeldFees({projectId: projectId, token: token, amount: amount}) : 0;\n\n        emit AddToBalance({\n            projectId: projectId,\n            amount: amount,\n            returnedFees: returnedFees,\n            memo: memo,\n            metadata: metadata,\n            caller: _msgSender()\n        });\n\n        // Record the added funds with any returned fees.\n        _recordAddedBalanceFor({projectId: projectId, token: token, amount: amount + returnedFees});\n    }\n\n    /// @notice Logic to be triggered before transferring tokens from this terminal.\n    /// @param to The address the transfer is going to.\n    /// @param token The token being transferred.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    /// @return payValue The value to attach to the transaction being sent.\n    function _beforeTransferTo(address to, address token, uint256 amount) internal returns (uint256) {\n        // If the token is the native token, no allowance needed, and the full amount should be used as the payValue.\n        if (token == JBConstants.NATIVE_TOKEN) return amount;\n\n        // Otherwise, set the allowance, and the payValue should be 0.\n        IERC20(token).safeIncreaseAllowance({spender: to, value: amount});\n        return 0;\n    }\n\n    /// @notice Holders can cash out their tokens to reclaim some of a project's surplus, or to trigger rules determined\n    /// by\n    /// the project's current ruleset's data hook.\n    /// @dev Only a token holder or an operator with the `CASH_OUT_TOKENS` permission from that holder can cash out\n    /// those\n    /// tokens.\n    /// @param holder The account cashing out tokens.\n    /// @param projectId The ID of the project whose tokens are being cashed out.\n    /// @param cashOutCount The number of project tokens to cash out, as a fixed point number with 18 decimals.\n    /// @param tokenToReclaim The address of the token which is being cashed out.\n    /// @param beneficiary The address to send the reclaimed terminal tokens to.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and cash out hook if\n    /// applicable.\n    /// @return reclaimAmount The number of terminal tokens reclaimed for the `beneficiary`, as a fixed point number\n    /// with 18 decimals.\n    function _cashOutTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        address tokenToReclaim,\n        address payable beneficiary,\n        bytes memory metadata\n    )\n        internal\n        returns (uint256 reclaimAmount)\n    {\n        // Keep a reference to the ruleset the cash out is being made during.\n        JBRuleset memory ruleset;\n\n        // Keep a reference to the cash out hook specifications.\n        JBCashOutHookSpecification[] memory hookSpecifications;\n\n        // Keep a reference to the cash out tax rate being used.\n        uint256 cashOutTaxRate;\n\n        // Keep a reference to the accounting context of the token being reclaimed.\n        JBAccountingContext memory accountingContext = _accountingContextForTokenOf[projectId][tokenToReclaim];\n\n        // Scoped section prevents stack too deep.\n        {\n            JBAccountingContext[] memory balanceAccountingContexts = _accountingContextsOf[projectId];\n\n            // Record the cash out.\n            (ruleset, reclaimAmount, cashOutTaxRate, hookSpecifications) = STORE.recordCashOutFor({\n                holder: holder,\n                projectId: projectId,\n                accountingContext: accountingContext,\n                balanceAccountingContexts: balanceAccountingContexts,\n                cashOutCount: cashOutCount,\n                metadata: metadata\n            });\n        }\n\n        // Burn the project tokens.\n        if (cashOutCount != 0) {\n            _controllerOf(projectId).burnTokensOf({\n                holder: holder,\n                projectId: projectId,\n                tokenCount: cashOutCount,\n                memo: \"\"\n            });\n        }\n\n        // Keep a reference to the amount being reclaimed that is subject to fees.\n        uint256 amountEligibleForFees;\n\n        // Send the reclaimed funds to the beneficiary.\n        if (reclaimAmount != 0) {\n            // Determine if a fee should be taken. Fees are not taked if the cash out tax rate is zero,\n            // if the beneficiary is feeless, or if the fee beneficiary doesn't accept the given token.\n            if (!_isFeeless(beneficiary) && cashOutTaxRate != 0) {\n                amountEligibleForFees += reclaimAmount;\n                // Subtract the fee for the reclaimed amount.\n                reclaimAmount -= JBFees.feeAmountFrom({amountBeforeFee: reclaimAmount, feePercent: FEE});\n            }\n\n            // Subtract the fee from the reclaim amount.\n            if (reclaimAmount != 0) {\n                _transferFrom({from: address(this), to: beneficiary, token: tokenToReclaim, amount: reclaimAmount});\n            }\n        }\n\n        // If the data hook returned cash out hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            // Fulfill the cash out hook specifications.\n            amountEligibleForFees += _fulfillCashOutHookSpecificationsFor({\n                projectId: projectId,\n                holder: holder,\n                cashOutCount: cashOutCount,\n                ruleset: ruleset,\n                cashOutTaxRate: cashOutTaxRate,\n                beneficiary: beneficiary,\n                beneficiaryReclaimAmount: JBTokenAmount({\n                    token: tokenToReclaim,\n                    decimals: accountingContext.decimals,\n                    currency: accountingContext.currency,\n                    value: reclaimAmount\n                }),\n                specifications: hookSpecifications,\n                metadata: metadata\n            });\n        }\n\n        // Take the fee from all outbound reclaimings.\n        amountEligibleForFees != 0\n            ? _takeFeeFrom({\n                projectId: projectId,\n                token: tokenToReclaim,\n                amount: amountEligibleForFees,\n                beneficiary: beneficiary,\n                shouldHoldFees: false\n            })\n            : 0;\n\n        emit CashOutTokens({\n            rulesetId: ruleset.id,\n            rulesetCycleNumber: ruleset.cycleNumber,\n            projectId: projectId,\n            holder: holder,\n            beneficiary: beneficiary,\n            cashOutCount: cashOutCount,\n            cashOutTaxRate: cashOutTaxRate,\n            reclaimAmount: reclaimAmount,\n            metadata: metadata,\n            caller: _msgSender()\n        });\n    }\n\n    /// @notice Fund a project either by calling this terminal's internal `addToBalance` function or by calling the\n    /// recipient\n    /// terminal's `addToBalance` function.\n    /// @param terminal The terminal on which the project is expecting to receive funds.\n    /// @param projectId The ID of the project being funded.\n    /// @param token The token being used.\n    /// @param amount The amount being funded, as a fixed point number with the amount of decimals that the terminal's\n    /// accounting context specifies.\n    /// @param metadata Additional metadata to include with the payment.\n    function _efficientAddToBalance(\n        IJBTerminal terminal,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Call the internal method if this terminal is being used.\n        if (terminal == IJBTerminal(address(this))) {\n            _addToBalanceOf({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: metadata\n            });\n        } else {\n            // Trigger any inherited pre-transfer logic.\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            // slither-disable-next-line reentrancy-events\n            uint256 payValue = _beforeTransferTo({to: address(terminal), token: token, amount: amount});\n\n            // Add to balance.\n            // If this terminal's token is the native token, send it in `msg.value`.\n            terminal.addToBalanceOf{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Pay a project either by calling this terminal's internal `pay` function or by calling the recipient\n    /// terminal's `pay` function.\n    /// @param terminal The terminal on which the project is expecting to receive payments.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The token being paid in.\n    /// @param amount The amount being paid, as a fixed point number with the amount of decimals that the terminal's\n    /// accounting context specifies.\n    /// @param beneficiary The address to receive any platform tokens minted.\n    /// @param metadata Additional metadata to include with the payment.\n    function _efficientPay(\n        IJBTerminal terminal,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        bytes memory metadata\n    )\n        internal\n    {\n        if (terminal == IJBTerminal(address(this))) {\n            _pay({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                payer: address(this),\n                beneficiary: beneficiary,\n                memo: \"\",\n                metadata: metadata\n            });\n        } else {\n            // Trigger any inherited pre-transfer logic.\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            // slither-disable-next-line reentrancy-events\n            uint256 payValue = _beforeTransferTo({to: address(terminal), token: token, amount: amount});\n\n            // Send the fee.\n            // If this terminal's token is ETH, send it in msg.value.\n            // slither-disable-next-line unused-return\n            terminal.pay{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                beneficiary: beneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Fulfills a list of pay hook specifications.\n    /// @param projectId The ID of the project being paid.\n    /// @param specifications The pay hook specifications to be fulfilled.\n    /// @param tokenAmount The amount of tokens that the project was paid.\n    /// @param payer The address that sent the payment.\n    /// @param ruleset The ruleset the payment is being accepted during.\n    /// @param beneficiary The address which will receive any tokens that the payment yields.\n    /// @param newlyIssuedTokenCount The amount of tokens that are being issued and sent to the beneificary.\n    /// @param metadata Bytes to send along to the emitted event and pay hooks as applicable.\n    function _fulfillPayHookSpecificationsFor(\n        uint256 projectId,\n        JBPayHookSpecification[] memory specifications,\n        JBTokenAmount memory tokenAmount,\n        address payer,\n        JBRuleset memory ruleset,\n        address beneficiary,\n        uint256 newlyIssuedTokenCount,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Keep a reference to payment context for the pay hooks.\n        JBAfterPayRecordedContext memory context = JBAfterPayRecordedContext({\n            payer: payer,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            amount: tokenAmount,\n            forwardedAmount: tokenAmount,\n            weight: ruleset.weight,\n            newlyIssuedTokenCount: newlyIssuedTokenCount,\n            beneficiary: beneficiary,\n            hookMetadata: bytes(\"\"),\n            payerMetadata: metadata\n        });\n\n        // Fulfill each specification through their pay hooks.\n        for (uint256 i; i < specifications.length; i++) {\n            // Set the specification being iterated on.\n            JBPayHookSpecification memory specification = specifications[i];\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: tokenAmount.token,\n                decimals: tokenAmount.decimals,\n                currency: tokenAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            // slither-disable-next-line reentrancy-events\n            uint256 payValue = _beforeTransferTo({\n                to: address(specification.hook),\n                token: tokenAmount.token,\n                amount: specification.amount\n            });\n\n            // Fulfill the specification.\n            // slither-disable-next-line reentrancy-events\n            specification.hook.afterPayRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordPay({\n                hook: specification.hook,\n                context: context,\n                specificationAmount: specification.amount,\n                caller: _msgSender()\n            });\n        }\n    }\n\n    /// @notice Fulfills a list of cash out hook specifications.\n    /// @param projectId The ID of the project being cashed out from.\n    /// @param beneficiaryReclaimAmount The number of tokens that are being cashed out from the project.\n    /// @param holder The address that holds the tokens being cashed out.\n    /// @param cashOutCount The number of tokens being cashed out.\n    /// @param metadata Bytes to send along to the emitted event and cash out hooks as applicable.\n    /// @param ruleset The ruleset the cash out is being made during as a `JBRuleset` struct.\n    /// @param cashOutTaxRate The cash out tax rate influencing the reclaim amount.\n    /// @param beneficiary The address which will receive any terminal tokens that are cashed out.\n    /// @param specifications The hook specifications being fulfilled.\n    /// @return amountEligibleForFees The amount of funds which were allocated to cash out hooks and are eligible for\n    /// fees.\n    function _fulfillCashOutHookSpecificationsFor(\n        uint256 projectId,\n        JBTokenAmount memory beneficiaryReclaimAmount,\n        address holder,\n        uint256 cashOutCount,\n        bytes memory metadata,\n        JBRuleset memory ruleset,\n        uint256 cashOutTaxRate,\n        address payable beneficiary,\n        JBCashOutHookSpecification[] memory specifications\n    )\n        internal\n        returns (uint256 amountEligibleForFees)\n    {\n        // Keep a reference to cash out context for the cash out hooks.\n        JBAfterCashOutRecordedContext memory context = JBAfterCashOutRecordedContext({\n            holder: holder,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            cashOutCount: cashOutCount,\n            reclaimedAmount: beneficiaryReclaimAmount,\n            forwardedAmount: beneficiaryReclaimAmount,\n            cashOutTaxRate: cashOutTaxRate,\n            beneficiary: beneficiary,\n            hookMetadata: \"\",\n            cashOutMetadata: metadata\n        });\n\n        for (uint256 i; i < specifications.length; i++) {\n            // Set the specification being iterated on.\n            JBCashOutHookSpecification memory specification = specifications[i];\n\n            // Get the fee for the specified amount.\n            uint256 specificationAmountFee = _isFeeless(address(specification.hook))\n                ? 0\n                : JBFees.feeAmountFrom({amountBeforeFee: specification.amount, feePercent: FEE});\n\n            // Add the specification's amount to the amount eligible for fees.\n            if (specificationAmountFee != 0) {\n                amountEligibleForFees += specification.amount;\n                specification.amount -= specificationAmountFee;\n            }\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: beneficiaryReclaimAmount.token,\n                decimals: beneficiaryReclaimAmount.decimals,\n                currency: beneficiaryReclaimAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            // slither-disable-next-line reentrancy-events\n            uint256 payValue = _beforeTransferTo({\n                to: address(specification.hook),\n                token: beneficiaryReclaimAmount.token,\n                amount: specification.amount\n            });\n\n            // Fulfill the specification.\n            // slither-disable-next-line reentrancy-events\n            specification.hook.afterCashOutRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordCashOut({\n                hook: specification.hook,\n                context: context,\n                specificationAmount: specification.amount,\n                fee: specificationAmountFee,\n                caller: _msgSender()\n            });\n        }\n    }\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The address of the token which the project is being paid with.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is the native token, `amount` is ignored and `msg.value` is\n    /// used in its place.\n    /// @param payer The address making the payment.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and pay hook if applicable.\n    function _pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address payer,\n        address beneficiary,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Keep a reference to the token amount to forward to the store.\n        JBTokenAmount memory tokenAmount;\n\n        // Scoped section prevents stack too deep. `context` only used within scope.\n        {\n            // Get a reference to the token's accounting context.\n            JBAccountingContext memory context = _accountingContextForTokenOf[projectId][token];\n\n            // Bundle the amount info into a `JBTokenAmount` struct.\n            tokenAmount =\n                JBTokenAmount({token: token, decimals: context.decimals, currency: context.currency, value: amount});\n        }\n\n        // Record the payment.\n        // Keep a reference to the ruleset the payment is being made during.\n        // Keep a reference to the pay hook specifications.\n        // Keep a reference to the token count that'll be minted as a result of the payment.\n        // slither-disable-next-line reentrancy-events\n        (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications) = STORE\n            .recordPaymentFrom({\n            payer: payer,\n            amount: tokenAmount,\n            projectId: projectId,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n\n        // Keep a reference to the number of tokens issued for the beneficiary.\n        uint256 newlyIssuedTokenCount;\n\n        // Mint tokens if needed.\n        if (tokenCount != 0) {\n            // Set the token count to be the number of tokens minted for the beneficiary instead of the total\n            // amount.\n            // slither-disable-next-line reentrancy-events\n            newlyIssuedTokenCount = _controllerOf(projectId).mintTokensOf({\n                projectId: projectId,\n                tokenCount: tokenCount,\n                beneficiary: beneficiary,\n                memo: \"\",\n                useReservedPercent: true\n            });\n        }\n\n        emit Pay({\n            rulesetId: ruleset.id,\n            rulesetCycleNumber: ruleset.cycleNumber,\n            projectId: projectId,\n            payer: payer,\n            beneficiary: beneficiary,\n            amount: amount,\n            newlyIssuedTokenCount: newlyIssuedTokenCount,\n            memo: memo,\n            metadata: metadata,\n            caller: _msgSender()\n        });\n\n        // If the data hook returned pay hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            _fulfillPayHookSpecificationsFor({\n                projectId: projectId,\n                specifications: hookSpecifications,\n                tokenAmount: tokenAmount,\n                payer: payer,\n                ruleset: ruleset,\n                beneficiary: beneficiary,\n                newlyIssuedTokenCount: newlyIssuedTokenCount,\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Process a fee of the specified amount from a project.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address which will receive any platform tokens minted.\n    /// @param feeTerminal The terminal that'll receive the fee.\n    /// @param wasHeld A flag indicating if the fee being processed was being held by this terminal.\n    function _processFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal,\n        bool wasHeld\n    )\n        internal\n    {\n        // slither-disable-next-line reentrancy-events,calls-loop\n        try this.executeProcessFee({\n            projectId: projectId,\n            token: token,\n            amount: amount,\n            beneficiary: beneficiary,\n            feeTerminal: feeTerminal\n        }) {\n            emit ProcessFee({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                wasHeld: wasHeld,\n                beneficiary: beneficiary,\n                caller: _msgSender()\n            });\n        } catch (bytes memory reason) {\n            emit FeeReverted({\n                projectId: projectId,\n                token: token,\n                feeProjectId: _FEE_BENEFICIARY_PROJECT_ID,\n                amount: amount,\n                reason: reason,\n                caller: _msgSender()\n            });\n\n            _recordAddedBalanceFor({projectId: projectId, token: token, amount: amount});\n        }\n    }\n\n    /// @notice Records an added balance for a project.\n    /// @param projectId The ID of the project to record the added balance for.\n    /// @param token The token to record the added balance for.\n    /// @param amount The amount of the token to record, as a fixed point number with the same number of decimals as\n    /// this\n    /// terminal.\n    function _recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) internal {\n        // slither-disable-next-line calls-loop\n        STORE.recordAddedBalanceFor({projectId: projectId, token: token, amount: amount});\n    }\n\n    /// @notice Returns held fees to the project who paid them based on the specified amount.\n    /// @param projectId The project held fees are being returned to.\n    /// @param token The token that the held fees are in.\n    /// @param amount The amount to base the calculation on, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    /// @return returnedFees The amount of held fees that were returned, as a fixed point number with the same number of\n    /// decimals as this terminal\n    function _returnHeldFees(\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256 returnedFees)\n    {\n        // Keep a reference to the start index.\n        uint256 startIndex = _nextHeldFeeIndexOf[projectId][token];\n\n        // Get a reference to the project's held fees.\n        uint256 numberOfHeldFees = _heldFeesOf[projectId][token].length;\n\n        // If the start index is greater than or equal to the number of held fees, return 0.\n        if (startIndex >= numberOfHeldFees) return 0;\n\n        // Get a reference to the leftover amount once all fees have been settled.\n        uint256 leftoverAmount = amount;\n\n        // Keep a reference to the number of iterations to perform.\n        uint256 count = numberOfHeldFees - startIndex;\n\n        // Keep a reference to the new start index.\n        uint256 newStartIndex = startIndex;\n\n        // Process each fee.\n        for (uint256 i; i < count; i++) {\n            // Save the fee being iterated on.\n            JBFee memory heldFee = _heldFeesOf[projectId][token][startIndex + i];\n\n            // slither-disable-next-line incorrect-equality\n            if (leftoverAmount == 0) {\n                break;\n            } else {\n                // Notice here we take `feeAmountFrom` on the stored `.amount`.\n                uint256 feeAmount = JBFees.feeAmountFrom({amountBeforeFee: heldFee.amount, feePercent: FEE});\n\n                // Keep a reference to the amount from which the fee was taken.\n                uint256 amountPaidOut = heldFee.amount - feeAmount;\n\n                if (leftoverAmount >= amountPaidOut) {\n                    unchecked {\n                        leftoverAmount -= amountPaidOut;\n                        returnedFees += feeAmount;\n                    }\n\n                    // Move the start index forward to the held fee after the current one.\n                    newStartIndex = startIndex + i + 1;\n                } else {\n                    // And here we overwrite with `feeAmountResultingIn` the `leftoverAmount`\n                    feeAmount = JBFees.feeAmountResultingIn({amountAfterFee: leftoverAmount, feePercent: FEE});\n\n                    // Get fee from `leftoverAmount`.\n                    unchecked {\n                        _heldFeesOf[projectId][token][startIndex + i].amount -= (leftoverAmount + feeAmount);\n                        returnedFees += feeAmount;\n                    }\n                    leftoverAmount = 0;\n                }\n            }\n        }\n\n        // Update the next held fee index.\n        if (startIndex != newStartIndex) _nextHeldFeeIndexOf[projectId][token] = newStartIndex;\n\n        emit ReturnHeldFees({\n            projectId: projectId,\n            token: token,\n            amount: amount,\n            returnedFees: returnedFees,\n            leftoverAmount: leftoverAmount,\n            caller: _msgSender()\n        });\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev Payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The token being paid out.\n    /// @param amount The number of terminal tokens to pay out, as a fixed point number with same number of decimals as\n    /// this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @return amountPaidOut The total amount that was paid out.\n    function _sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency\n    )\n        internal\n        returns (uint256 amountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Record the payout.\n        (ruleset, amountPaidOut) = STORE.recordPayoutFor({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // Get a reference to the project's owner.\n        // The owner will receive tokens minted by paying the platform fee and receive any leftover funds not sent to\n        // payout splits.\n        address payable projectOwner = payable(_ownerOf(projectId));\n\n        // If the ruleset requires privileged payout distribution, ensure the caller has the permission.\n        if (ruleset.ownerMustSendPayouts()) {\n            // Enforce permissions.\n            _requirePermissionFrom({\n                account: projectOwner,\n                projectId: projectId,\n                permissionId: JBPermissionIds.SEND_PAYOUTS\n            });\n        }\n\n        // Send payouts to the splits and get a reference to the amount left over after the splits have been paid.\n        // Also get a reference to the amount which was paid out to splits that is eligible for fees.\n        (uint256 leftoverPayoutAmount, uint256 amountEligibleForFees) = _sendPayoutsToSplitGroupOf({\n            projectId: projectId,\n            token: token,\n            rulesetId: ruleset.id,\n            amount: amountPaidOut\n        });\n\n        // Send any leftover funds to the project owner and update the fee tracking accordingly.\n        if (leftoverPayoutAmount != 0) {\n            // Keep a reference to the fee for the leftover payout amount.\n            uint256 fee = _isFeeless(projectOwner)\n                ? 0\n                : JBFees.feeAmountFrom({amountBeforeFee: leftoverPayoutAmount, feePercent: FEE});\n\n            // Transfer the amount to the project owner.\n            try this.executeTransferTo({addr: projectOwner, token: token, amount: leftoverPayoutAmount - fee}) {\n                if (fee > 0) {\n                    amountEligibleForFees += leftoverPayoutAmount;\n                    leftoverPayoutAmount -= fee;\n                }\n            } catch (bytes memory reason) {\n                emit PayoutTransferReverted({\n                    projectId: projectId,\n                    addr: projectOwner,\n                    token: token,\n                    amount: leftoverPayoutAmount - fee,\n                    fee: fee,\n                    reason: reason,\n                    caller: _msgSender()\n                });\n\n                // Add balance back to the project.\n                _recordAddedBalanceFor({projectId: projectId, token: token, amount: leftoverPayoutAmount});\n            }\n        }\n\n        // Take the fee.\n        uint256 feeTaken = _takeFeeFrom({\n            projectId: projectId,\n            token: token,\n            amount: amountEligibleForFees,\n            beneficiary: projectOwner,\n            shouldHoldFees: ruleset.holdFees()\n        });\n\n        emit SendPayouts({\n            rulesetId: ruleset.id,\n            rulesetCycleNumber: ruleset.cycleNumber,\n            projectId: projectId,\n            projectOwner: projectOwner,\n            amount: amount,\n            amountPaidOut: amountPaidOut,\n            fee: feeTaken,\n            netLeftoverPayoutAmount: leftoverPayoutAmount,\n            caller: _msgSender()\n        });\n    }\n\n    /// @notice Sends a payout to a split.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split was specified by.\n    /// @param token The address of the token being paid out.\n    /// @param amount The total amount that the split is being paid, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function _sendPayoutToSplit(\n        JBSplit memory split,\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256)\n    {\n        // Attempt to distribute this split.\n        // slither-disable-next-line reentrancy-events\n        try this.executePayout({\n            split: split,\n            projectId: projectId,\n            token: token,\n            amount: amount,\n            originalMessageSender: _msgSender()\n        }) returns (uint256 netPayoutAmount) {\n            return netPayoutAmount;\n        } catch (bytes memory failureReason) {\n            emit PayoutReverted({\n                projectId: projectId,\n                split: split,\n                amount: amount,\n                reason: failureReason,\n                caller: _msgSender()\n            });\n\n            // Add balance back to the project.\n            _recordAddedBalanceFor({projectId: projectId, token: token, amount: amount});\n\n            // Since the payout failed the netPayoutAmount is zero.\n            return 0;\n        }\n    }\n\n    /// @notice Sends payouts to the payout splits group specified in a project's ruleset.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The address of the token being paid out.\n    /// @param rulesetId The ID of the ruleset of the split group being paid.\n    /// @param amount The total amount being paid out, as a fixed point number with the same number of decimals as this\n    /// terminal.\n    /// @return amount The leftover amount (zero if the splits add up to 100%).\n    /// @return amountEligibleForFees The total amount of funds which were paid out and are eligible for fees.\n    function _sendPayoutsToSplitGroupOf(\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 amount\n    )\n        internal\n        returns (uint256, uint256 amountEligibleForFees)\n    {\n        // The total percentage available to split\n        uint256 leftoverPercentage = JBConstants.SPLITS_TOTAL_PERCENT;\n\n        // Get a reference to the project's payout splits.\n        JBSplit[] memory splits =\n            SPLITS.splitsOf({projectId: projectId, rulesetId: rulesetId, groupId: uint256(uint160(token))});\n\n        // Transfer between all splits.\n        for (uint256 i; i < splits.length; i++) {\n            // Get a reference to the split being iterated on.\n            JBSplit memory split = splits[i];\n\n            // The amount to send to the split.\n            uint256 payoutAmount = mulDiv(amount, split.percent, leftoverPercentage);\n\n            // The final payout amount after taking out any fees.\n            uint256 netPayoutAmount =\n                _sendPayoutToSplit({split: split, projectId: projectId, token: token, amount: payoutAmount});\n\n            // If the split hook is a feeless address, this payout doesn't incur a fee.\n            if (netPayoutAmount != 0 && netPayoutAmount != payoutAmount) {\n                amountEligibleForFees += payoutAmount;\n            }\n\n            if (payoutAmount != 0) {\n                // Subtract from the amount to be sent to the beneficiary.\n                unchecked {\n                    amount -= payoutAmount;\n                }\n            }\n\n            unchecked {\n                // Decrement the leftover percentage.\n                leftoverPercentage -= split.percent;\n            }\n\n            emit SendPayoutToSplit({\n                projectId: projectId,\n                rulesetId: rulesetId,\n                group: uint256(uint160(token)),\n                split: split,\n                amount: payoutAmount,\n                netAmount: netPayoutAmount,\n                caller: _msgSender()\n            });\n        }\n\n        return (amount, amountEligibleForFees);\n    }\n\n    /// @notice Takes a fee into the platform's project (with the `_FEE_BENEFICIARY_PROJECT_ID`).\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The address of the token that the fee is being paid in.\n    /// @param amount The fee's token amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint the platform's project's tokens for.\n    /// @param shouldHoldFees If fees should be tracked and held instead of being exercised immediately.\n    /// @return feeAmount The amount of the fee taken.\n    function _takeFeeFrom(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        bool shouldHoldFees\n    )\n        internal\n        returns (uint256 feeAmount)\n    {\n        // Get a reference to the fee amount.\n        feeAmount = JBFees.feeAmountFrom({amountBeforeFee: amount, feePercent: FEE});\n\n        if (shouldHoldFees) {\n            // Store the held fee.\n            _heldFeesOf[projectId][token].push(\n                JBFee({\n                    amount: amount,\n                    beneficiary: beneficiary,\n                    unlockTimestamp: uint48(block.timestamp + _FEE_HOLDING_SECONDS)\n                })\n            );\n\n            emit HoldFee({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                fee: FEE,\n                beneficiary: beneficiary,\n                caller: _msgSender()\n            });\n        } else {\n            // Get the terminal that'll receive the fee if one wasn't provided.\n            IJBTerminal feeTerminal = _primaryTerminalOf({projectId: _FEE_BENEFICIARY_PROJECT_ID, token: token});\n\n            // Process the fee.\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: feeAmount,\n                beneficiary: beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: false\n            });\n        }\n    }\n\n    /// @notice Transfers tokens.\n    /// @param from The address the transfer should originate from.\n    /// @param to The address the transfer should go to.\n    /// @param token The token being transfered.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    function _transferFrom(address from, address payable to, address token, uint256 amount) internal {\n        if (from == address(this)) {\n            // If the token is the native token, transfer natively.\n            if (token == JBConstants.NATIVE_TOKEN) return Address.sendValue({recipient: to, amount: amount});\n\n            return IERC20(token).safeTransfer({to: to, value: amount});\n        }\n\n        // If there's sufficient approval, transfer normally.\n        if (IERC20(token).allowance(address(from), address(this)) >= amount) {\n            return IERC20(token).safeTransferFrom({from: from, to: to, value: amount});\n        }\n\n        // Make sure the amount being paid is less than the maximum permit2 allowance.\n        if (amount > type(uint160).max) revert JBMultiTerminal_OverflowAlert(amount, type(uint160).max);\n\n        // Otherwise we attempt to use the PERMIT2 method.\n        PERMIT2.transferFrom({from: from, to: to, amount: uint160(amount), token: token});\n    }\n\n    /// @notice Allows a project to send out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param owner The project's owner.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param beneficiary The address to send the funds to.\n    /// @param feeBeneficiary The address to send the tokens resulting from paying the fee.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return netAmountPaidOut The amount of tokens paid out.\n    function _useAllowanceOf(\n        uint256 projectId,\n        address owner,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        address payable beneficiary,\n        address payable feeBeneficiary,\n        string memory memo\n    )\n        internal\n        returns (uint256 netAmountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Keep a reference to the amount paid out before fees.\n        uint256 amountPaidOut;\n\n        // Record the use of the allowance.\n        (ruleset, amountPaidOut) = STORE.recordUsedAllowanceOf({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // Take a fee from the `amountPaidOut`, if needed.\n        // The net amount is the final amount withdrawn after the fee has been taken.\n        // slither-disable-next-line reentrancy-events\n        netAmountPaidOut = amountPaidOut\n            - (\n                _isFeeless(owner) || _isFeeless(beneficiary)\n                    ? 0\n                    : _takeFeeFrom({\n                        projectId: projectId,\n                        token: token,\n                        amount: amountPaidOut,\n                        // The project owner will receive tokens minted by paying the platform fee.\n                        beneficiary: feeBeneficiary,\n                        shouldHoldFees: ruleset.holdFees()\n                    })\n            );\n\n        emit UseAllowance({\n            rulesetId: ruleset.id,\n            rulesetCycleNumber: ruleset.cycleNumber,\n            projectId: projectId,\n            beneficiary: beneficiary,\n            feeBeneficiary: feeBeneficiary,\n            amount: amount,\n            amountPaidOut: amountPaidOut,\n            netAmountPaidOut: netAmountPaidOut,\n            memo: memo,\n            caller: _msgSender()\n        });\n\n        // Transfer any remaining balance to the beneficiary.\n        if (netAmountPaidOut != 0) {\n            _transferFrom({from: address(this), to: beneficiary, token: token, amount: netAmountPaidOut});\n        }\n    }\n}\n"},"src/structs/JBFee.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The total amount the fee was taken from, as a fixed point number with the same number of\n/// decimals as the terminal in which this struct was created.\n/// @custom:member beneficiary The address that will receive the tokens that are minted as a result of the fee payment.\n/// @custom:member unlockTimestamp The timestamp at which the fee is unlocked and can be processed.\nstruct JBFee {\n    uint256 amount;\n    address beneficiary;\n    uint48 unlockTimestamp;\n}\n"},"src/interfaces/IJBTerminalStore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBAccountingContext} from \"./../structs/JBAccountingContext.sol\";\nimport {JBCashOutHookSpecification} from \"./../structs/JBCashOutHookSpecification.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./../structs/JBTokenAmount.sol\";\n\ninterface IJBTerminalStore {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PRICES() external view returns (IJBPrices);\n    function RULESETS() external view returns (IJBRulesets);\n\n    function balanceOf(address terminal, uint256 projectId, address token) external view returns (uint256);\n    function usedPayoutLimitOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetCycleNumber,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function usedSurplusAllowanceOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 cashOutCount,\n        IJBTerminal[] calldata terminals,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external;\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount memory amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications);\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut);\n    function recordCashOutFor(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes calldata metadata\n    )\n        external\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 cashOutTaxRate,\n            JBCashOutHookSpecification[] memory hookSpecifications\n        );\n    function recordTerminalMigration(uint256 projectId, address token) external returns (uint256 balance);\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 usedAmount);\n}\n"},"src/interfaces/IJBFeelessAddresses.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBFeelessAddresses {\n    event SetFeelessAddress(address indexed addr, bool indexed isFeeless, address caller);\n\n    function isFeeless(address account) external view returns (bool);\n\n    function setFeelessAddress(address account, bool flag) external;\n}\n"},"src/interfaces/IJBPayoutTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBSplit} from \"../structs/JBSplit.sol\";\n\n/// @notice A terminal that can send payouts.\ninterface IJBPayoutTerminal is IJBTerminal {\n    event PayoutReverted(uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller);\n    event PayoutTransferReverted(\n        uint256 indexed projectId,\n        address addr,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes reason,\n        address caller\n    );\n    event SendPayouts(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address projectOwner,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 fee,\n        uint256 netLeftoverPayoutAmount,\n        address caller\n    );\n    event SendPayoutToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 amount,\n        uint256 netAmount,\n        address caller\n    );\n    event UseAllowance(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        address feeBeneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 netAmountPaidOut,\n        string memo,\n        address caller\n    );\n\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        returns (uint256 netLeftoverPayoutAmount);\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        address payable feeBeneficiary,\n        string calldata memo\n    )\n        external\n        returns (uint256 netAmountPaidOut);\n}\n"},"src/interfaces/IJBProjects.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n    function setTokenUriResolver(IJBTokenUriResolver resolver) external;\n}\n"},"src/structs/JBAfterPayRecordedContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member newlyIssuedTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 newlyIssuedTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"},"src/structs/JBTerminalConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"},"src/interfaces/IJBPermissions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"},"src/abstract/JBPermissioned.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n\n    error JBPermissioned_Unauthorized(address account, address sender, uint256 projectId, uint256 permissionId);\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert JBPermissioned_Unauthorized(account, sender, projectId, permissionId);\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"},"src/interfaces/IJBTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBPayHook} from \"./IJBPayHook.sol\";\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 returnedFees, string memo, bytes metadata, address caller\n    );\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 newlyIssuedTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n    function currentSurplusOf(\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n}\n"},"src/interfaces/IJBTokens.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 count,\n        uint256 creditBalance,\n        uint256 tokenBalance,\n        address caller\n    );\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 creditBalance,\n        uint256 count,\n        address beneficiary,\n        address caller\n    );\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 count, bool tokensWereClaimed, address caller\n    );\n    event SetToken(uint256 indexed projectId, IJBToken indexed token, address caller);\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 count, address caller\n    );\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n    function projectIdOf(IJBToken token) external view returns (uint256);\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function burnFrom(address holder, uint256 projectId, uint256 count) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 count, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function mintFor(address holder, uint256 projectId, uint256 count) external returns (IJBToken token);\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 count) external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"},"src/structs/JBSingleAllowance.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member sigDeadline Deadline on the permit signature.\n/// @custom:member amount The maximum amount allowed to spend.\n/// @custom:member expiration Timestamp at which a spender's token allowances become invalid.\n/// @custom:member nonce An incrementing value indexed per owner,token,and spender for each signature.\n/// @custom:member signature The signature over the permit data. Supports EOA signatures, compact signatures defined by\n/// EIP-2098, and contract signatures defined by EIP-1271.\nstruct JBSingleAllowance {\n    uint256 sigDeadline;\n    uint160 amount;\n    uint48 expiration;\n    uint48 nonce;\n    bytes signature;\n}\n"},"src/structs/JBCashOutHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutHook} from \"../interfaces/IJBCashOutHook.sol\";\n\n/// @notice A cash out hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The cash out hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBCashOutHookSpecification {\n    IJBCashOutHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/interfaces/IJBMultiTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutTerminal} from \"./IJBCashOutTerminal.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBFeeTerminal} from \"./IJBFeeTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./IJBPayoutTerminal.sol\";\nimport {IJBPermitTerminal} from \"./IJBPermitTerminal.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./IJBTerminalStore.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\n\ninterface IJBMultiTerminal is IJBTerminal, IJBFeeTerminal, IJBCashOutTerminal, IJBPayoutTerminal, IJBPermitTerminal {\n    function DIRECTORY() external view returns (IJBDirectory);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function STORE() external view returns (IJBTerminalStore);\n    function TOKENS() external view returns (IJBTokens);\n}\n"},"src/structs/JBRulesetConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a cut `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member weightCutPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if\n/// the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_WEIGHT_CUT_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"},"node_modules/@bananapus/permission-ids-v5/src/JBPermissionIds.sol":{"content":"// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant CASH_OUT_TOKENS = 3; // Permission to call `JBMultiTerminal.cashOutTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n    uint8 internal constant SET_721_DISCOUNT_PERCENT = 23; // Permission to call `JB721TiersHook.setDiscountPercentOf`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n    uint8 internal constant SUCKER_SAFETY = 30; // Permission to call `BPSucker.enableEmergencyHatchFor` and\n        // `BPSucker.setDeprecation`.\n}\n"},"src/interfaces/IJBTokenUriResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"},"src/structs/JBTokenAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"},"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC-2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC-2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"},"src/interfaces/IJBPermissioned.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"},"src/libraries/JBMetadataResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error JBMetadataResolver_DataNotPadded();\n    error JBMetadataResolver_LengthMismatch();\n    error JBMetadataResolver_MetadataTooLong();\n    error JBMetadataResolver_MetadataTooShort();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /// @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n    /// @param originalMetadata The original metadata\n    /// @param idToAdd The id to add\n    /// @param dataToAdd The data to add\n    /// @return newMetadata The new metadata with the entry added\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert JBMetadataResolver_MetadataTooShort();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert JBMetadataResolver_DataNotPadded();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                uint256 lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /// @notice Create the metadata for a list of {id:data}\n    /// @dev Intended for offchain use (gas heavy)\n    /// @param ids The list of ids\n    /// @param datas The list of corresponding datas\n    /// @return metadata The resulting metadata\n    function createMetadata(bytes4[] memory ids, bytes[] memory datas) internal pure returns (bytes memory metadata) {\n        if (ids.length != datas.length) revert JBMetadataResolver_LengthMismatch();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        offset += ((ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // Keep a reference to the number of ids.\n        uint256 numberOfIds = ids.length;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 i; i < numberOfIds; ++i) {\n            // Set the data being iterated on.\n            bytes memory data = datas[i];\n\n            if (data.length < 32 || data.length % JBMetadataResolver.WORD_SIZE != 0) {\n                revert JBMetadataResolver_DataNotPadded();\n            }\n\n            metadata = abi.encodePacked(metadata, ids[i], bytes1(uint8(offset)));\n            offset += data.length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (offset > 255) revert JBMetadataResolver_MetadataTooLong();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, paddedLength)\n        }\n\n        // Keep a reference to the number of datas.\n        uint256 numberOfDatas = datas.length;\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 i; i < numberOfDatas; i++) {\n            metadata = abi.encodePacked(metadata, datas[i]);\n            paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, paddedLength)\n            }\n        }\n    }\n\n    /// @notice Parse the metadata to find the data for a specific ID\n    /// @dev Returns false and an empty bytes if no data is found\n    /// @param id The ID to find.\n    /// @param metadata The metadata to parse.\n    /// @return found Whether the {id:data} was found\n    /// @return targetData The data for the ID (can be empty)\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            // Set the current offset.\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @return id The resulting ID.\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /// @notice Returns an unique id following a suggested format (`xor(address(this), purpose name)` where purpose name\n    /// is a string giving context to the id (Permit2, quoteForSwap, etc)\n    /// @param purpose A string describing the purpose associated with the id\n    /// @param target The target which will use the metadata\n    /// @return id The resulting ID.\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        private\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"src/structs/JBPermissionsData.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint64 projectId;\n    uint8[] permissionIds;\n}\n"},"src/interfaces/IJBCashOutTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBCashOutHook} from \"./IJBCashOutHook.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBAfterCashOutRecordedContext} from \"../structs/JBAfterCashOutRecordedContext.sol\";\n\n/// @notice A terminal that can be cashed out from.\ninterface IJBCashOutTerminal is IJBTerminal {\n    event HookAfterRecordCashOut(\n        IJBCashOutHook indexed hook,\n        JBAfterCashOutRecordedContext context,\n        uint256 specificationAmount,\n        uint256 fee,\n        address caller\n    );\n    event CashOutTokens(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address holder,\n        address beneficiary,\n        uint256 cashOutCount,\n        uint256 cashOutTaxRate,\n        uint256 reclaimAmount,\n        bytes metadata,\n        address caller\n    );\n\n    function cashOutTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 cashOutCount,\n        address tokenToReclaim,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (uint256 reclaimAmount);\n}\n"},"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"},"src/enums/JBApprovalStatus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"},"src/interfaces/IJBPermitTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBPermitTerminal is IJBTerminal {\n    function PERMIT2() external returns (IPermit2);\n}\n"},"src/structs/JBFundAccessLimitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"},"src/structs/JBPayHookSpecification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"},"src/structs/JBRulesetWithMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"},"src/interfaces/IJBPriceFeed.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"},"src/interfaces/IJBSplitHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"},"src/structs/JBSplitHookContext.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"},"node_modules/@prb/math/src/Common.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The maximum value a uint64 number can have.\nuint64 constant MAX_UINT64 = type(uint64).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y÷1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*y÷denominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"},"src/interfaces/IJBFundAccessLimits.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        JBFundAccessLimitGroup fundAccessLimitGroup,\n        address caller\n    );\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessLimitGroups\n    )\n        external;\n}\n"},"src/libraries/JBConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_CASH_OUT_TAX_RATE = 10_000;\n    uint32 public constant MAX_WEIGHT_CUT_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"},"src/libraries/JBRulesetMetadataResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function cashOutTaxRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Cash out tax rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function useTotalSurplusForCashOuts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 80) & 1 == 1;\n    }\n\n    function useDataHookForCashOut(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 82));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 242);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // cash out tax rate in bits 20-35 (16 bits).\n        // cash out tax rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.cashOutTaxRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow controller migration in bit 77.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 77;\n        // hold fees in bit 78.\n        if (rulesetMetadata.holdFees) packed |= 1 << 78;\n        // useTotalSurplusForCashOuts in bit 79.\n        if (rulesetMetadata.useTotalSurplusForCashOuts) packed |= 1 << 79;\n        // use pay data source in bit 80.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 80;\n        // use cash out data source in bit 81.\n        if (rulesetMetadata.useDataHookForCashOut) packed |= 1 << 81;\n        // data source address in bits 82-241.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 82;\n        // metadata in bits 242-255 (14 bits).\n        packed |= (uint256(rulesetMetadata.metadata) & 0x3FFF) << 242;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            cashOutTaxRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForCashOuts(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForCashOut(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"},"src/structs/JBSplitGroup.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"},"src/interfaces/IJBController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n    event DeployERC20(\n        uint256 indexed projectId, address indexed deployer, bytes32 salt, bytes32 saltHash, address caller\n    );\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string projectUri, string memo, address caller);\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 tokenCount, bytes reason, address caller\n    );\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed groupId,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address owner,\n        uint256 tokenCount,\n        uint256 leftoverAmount,\n        address caller\n    );\n    event SetUri(uint256 indexed projectId, string uri, address caller);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n    function PRICES() external view returns (IJBPrices);\n    function PROJECTS() external view returns (IJBProjects);\n    function RULESETS() external view returns (IJBRulesets);\n    function SPLITS() external view returns (IJBSplits);\n    function TOKENS() external view returns (IJBTokens);\n    function OMNICHAIN_RULESET_OPERATOR() external view returns (address);\n\n    function allRulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n    function claimTokensFor(address holder, uint256 projectId, uint256 tokenCount, address beneficiary) external;\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 creditCount) external;\n}\n"},"src/interfaces/IJBDirectory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed isAllowed, address caller);\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n}\n"},"src/structs/JBRulesetMetadata.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member cashOutTaxRate The cash out tax rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_CASH_OUT_TAX_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForCashOuts A flag indicating if cash outs should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the cash out is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForCashOut A flag indicating if the data hook should be used for cash out transactions\n/// during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, only the 14 least significant bits can be used, the 2 most\n/// significant bits are disregarded.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 cashOutTaxRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForCashOuts;\n    bool useDataHookForPay;\n    bool useDataHookForCashOut;\n    address dataHook;\n    uint16 metadata;\n}\n"},"src/interfaces/IJBCashOutHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterCashOutRecordedContext} from \"./../structs/JBAfterCashOutRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `cashOutTokensOf(...)` logic completes (if passed by the ruleset's data\n/// hook).\ninterface IJBCashOutHook is IERC165 {\n    /// @notice This function is called by the terminal's `cashOutTokensOf(...)` function after the cash out has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterCashOutRecordedContext` struct.\n    function afterCashOutRecordedWith(JBAfterCashOutRecordedContext calldata context) external payable;\n}\n"},"node_modules/@openzeppelin/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"},"src/interfaces/IJBToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function balanceOf(address account) external view returns (uint256);\n    function canBeAddedTo(uint256 projectId) external view returns (bool);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n    function burn(address account, uint256 amount) external;\n    function mint(address account, uint256 amount) external;\n}\n"},"src/interfaces/IJBRulesetApprovalHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) external view returns (JBApprovalStatus);\n}\n"},"src/interfaces/IJBRulesets.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetInitialized(\n        uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId, address caller\n    );\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event WeightCacheUpdated(uint256 projectId, uint112 weight, uint256 weightCutMultiple, address caller);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n    function deriveCycleNumberFrom(\n        uint256 baseRulesetCycleNumber,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 start\n    )\n        external\n        returns (uint256);\n    function deriveStartFrom(\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        view\n        returns (uint256 start);\n    function deriveWeightFrom(\n        uint256 projectId,\n        uint256 baseRulesetStart,\n        uint256 baseRulesetDuration,\n        uint256 baseRulesetWeight,\n        uint256 baseRulesetWeightCutPercent,\n        uint256 baseRulesetCacheId,\n        uint256 start\n    )\n        external\n        view\n        returns (uint256 weight);\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n    function allOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 weightCutPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"},"src/structs/JBCurrencyAmount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"},"src/interfaces/IJBPayHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"},"src/structs/JBSplit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    uint32 percent;\n    uint64 projectId;\n    address payable beneficiary;\n    bool preferAddToBalance;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"},"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"},"src/libraries/JBFees.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./../libraries/JBConstants.sol\";\n\n/// @notice Fee calculations.\nlibrary JBFees {\n    /// @notice Returns the amount of tokens to pay as a fee relative to the specified `amount`.\n    /// @param amountAfterFee The amount that the fee is based on, as a fixed point number.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of tokens to pay as a fee, as a fixed point number with the same number of decimals as the\n    /// provided `amount`.\n    function feeAmountResultingIn(uint256 amountAfterFee, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return mulDiv(amountAfterFee, JBConstants.MAX_FEE, JBConstants.MAX_FEE - feePercent) - amountAfterFee;\n    }\n\n    /// @notice Returns the fee that would have been paid based on an `amount` which has already had the fee subtracted\n    /// from it.\n    /// @param amountBeforeFee The amount that the fee is based on, as a fixed point number with the same amount of\n    /// decimals as\n    /// this terminal.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n    function feeAmountFrom(uint256 amountBeforeFee, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return mulDiv(amountBeforeFee, feePercent, JBConstants.MAX_FEE);\n    }\n}\n"},"src/structs/JBRuleset.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `weightCutPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member weightCutPercent The percentage by which to reduce the `weight` each time a new ruleset starts.\n/// `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_WEIGHT_CUT_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `weightCutPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 weightCutPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"src/interfaces/IJBFeeTerminal.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBFeelessAddresses} from \"./IJBFeelessAddresses.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {JBFee} from \"../structs/JBFee.sol\";\n\n/// @notice A terminal that can process and hold fees.\ninterface IJBFeeTerminal is IJBTerminal {\n    event FeeReverted(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed feeProjectId,\n        uint256 amount,\n        bytes reason,\n        address caller\n    );\n    event HoldFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 fee,\n        address beneficiary,\n        address caller\n    );\n    event ProcessFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        bool wasHeld,\n        address beneficiary,\n        address caller\n    );\n    event ReturnHeldFees(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 returnedFees,\n        uint256 leftoverAmount,\n        address caller\n    );\n\n    function FEE() external view returns (uint256);\n    function FEELESS_ADDRESSES() external view returns (IJBFeelessAddresses);\n\n    function heldFeesOf(uint256 projectId, address token, uint256 count) external view returns (JBFee[] memory);\n    function processHeldFeesOf(uint256 projectId, address token, uint256 count) external;\n}\n"},"node_modules/@openzeppelin/contracts/utils/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"src/interfaces/IJBDirectoryAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"},"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"}},"settings":{"evmVersion":"paris","metadata":{"appendCBOR":true,"bytecodeHash":"ipfs","useLiteralContent":false},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/","@arbitrum/=node_modules/@arbitrum/","@bananapus/=node_modules/@bananapus/","@chainlink/=node_modules/@chainlink/","@eth-optimism/=node_modules/@eth-optimism/","@offchainlabs/=node_modules/@offchainlabs/","@openzeppelin/=node_modules/@openzeppelin/","@prb/=node_modules/@prb/","@scroll-tech/=node_modules/@scroll-tech/","@uniswap/=node_modules/@uniswap/","@zksync/=node_modules/@zksync/","forge-std/=lib/forge-std/src/","hardhat/=node_modules/hardhat/","solmate/=node_modules/solmate/","sphinx/=lib/sphinx/packages/contracts/contracts/forge-std/src/"],"viaIR":false}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IJBFeelessAddresses\",\"name\":\"feelessAddresses\",\"type\":\"address\"},{\"internalType\":\"contract IJBPermissions\",\"name\":\"permissions\",\"type\":\"address\"},{\"internalType\":\"contract IJBProjects\",\"name\":\"projects\",\"type\":\"address\"},{\"internalType\":\"contract IJBSplits\",\"name\":\"splits\",\"type\":\"address\"},{\"internalType\":\"contract IJBTerminalStore\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"contract IJBTokens\",\"name\":\"tokens\",\"type\":\"address\"},{\"internalType\":\"contract IPermit2\",\"name\":\"permit2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FailedCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"needed\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"JBMultiTerminal_AccountingContextAlreadySet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBMultiTerminal_AddingAccountingContextNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBMultiTerminal_FeeTerminalNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_NoMsgValueAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_OverflowAlert\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_PermitAllowanceNotEnough\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"JBMultiTerminal_RecipientProjectTerminalNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"name\":\"JBMultiTerminal_SplitHookInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBMultiTerminal_TerminalTokensIncompatible\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"JBMultiTerminal_TokenNotAccepted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_UnderMinReturnedTokens\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_UnderMinTokensPaidOut\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"JBMultiTerminal_UnderMinTokensReclaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBMultiTerminal_ZeroAccountingContextCurrency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JBMultiTerminal_ZeroAccountingContextDecimals\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"permissionId\",\"type\":\"uint256\"}],\"name\":\"JBPermissioned_Unauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath_MulDiv_Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"AddToBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cashOutTaxRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reclaimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"CashOutTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"feeProjectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"FeeReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"HoldFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IJBCashOutHook\",\"name\":\"hook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct JBTokenAmount\",\"name\":\"reclaimedAmount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct JBTokenAmount\",\"name\":\"forwardedAmount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"cashOutTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hookMetadata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"cashOutMetadata\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct JBAfterCashOutRecordedContext\",\"name\":\"context\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"specificationAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"HookAfterRecordCashOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IJBPayHook\",\"name\":\"hook\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct JBTokenAmount\",\"name\":\"amount\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct JBTokenAmount\",\"name\":\"forwardedAmount\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newlyIssuedTokenCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hookMetadata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"payerMetadata\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct JBAfterPayRecordedContext\",\"name\":\"context\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"specificationAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"HookAfterRecordPay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IJBTerminal\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MigrateTerminal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newlyIssuedTokenCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Pay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct JBSplit\",\"name\":\"split\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"PayoutReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"PayoutTransferReverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"wasHeld\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ProcessFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leftoverAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ReturnHeldFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"group\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct JBSplit\",\"name\":\"split\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SendPayoutToSplit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"projectOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaidOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netLeftoverPayoutAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SendPayouts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct JBAccountingContext\",\"name\":\"context\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SetAccountingContext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rulesetCycleNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaidOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"netAmountPaidOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"UseAllowance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DIRECTORY\",\"outputs\":[{\"internalType\":\"contract IJBDirectory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEELESS_ADDRESSES\",\"outputs\":[{\"internalType\":\"contract IJBFeelessAddresses\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMISSIONS\",\"outputs\":[{\"internalType\":\"contract IJBPermissions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECTS\",\"outputs\":[{\"internalType\":\"contract IJBProjects\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RULESETS\",\"outputs\":[{\"internalType\":\"contract IJBRulesets\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SPLITS\",\"outputs\":[{\"internalType\":\"contract IJBSplits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STORE\",\"outputs\":[{\"internalType\":\"contract IJBTerminalStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENS\",\"outputs\":[{\"internalType\":\"contract IJBTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"accountingContextForTokenOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"}],\"name\":\"accountingContextsOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContexts\",\"type\":\"tuple[]\"}],\"name\":\"addAccountingContextsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"shouldReturnHeldFees\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"addToBalanceOf\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cashOutCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenToReclaim\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minTokensReclaimed\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"cashOutTokensOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"currency\",\"type\":\"uint32\"}],\"internalType\":\"struct JBAccountingContext[]\",\"name\":\"accountingContexts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"}],\"name\":\"currentSurplusOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"percent\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"projectId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"preferAddToBalance\",\"type\":\"bool\"},{\"internalType\":\"uint48\",\"name\":\"lockedUntil\",\"type\":\"uint48\"},{\"internalType\":\"contract IJBSplitHook\",\"name\":\"hook\",\"type\":\"address\"}],\"internalType\":\"struct JBSplit\",\"name\":\"split\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"originalMessageSender\",\"type\":\"address\"}],\"name\":\"executePayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netPayoutAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"contract IJBTerminal\",\"name\":\"feeTerminal\",\"type\":\"address\"}],\"name\":\"executeProcessFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeTransferTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"heldFeesOf\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"unlockTimestamp\",\"type\":\"uint48\"}],\"internalType\":\"struct JBFee[]\",\"name\":\"heldFees\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IJBTerminal\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"migrateBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minReturnedTokens\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"pay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"beneficiaryTokenCount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"processHeldFeesOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokensPaidOut\",\"type\":\"uint256\"}],\"name\":\"sendPayoutsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPaidOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currency\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minTokensPaidOut\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"useAllowanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"netAmountPaidOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"JBMultiTerminal","CompilerVersion":"v0.8.23+commit.f704f362","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x000000000000000000000000fc702a0190f3edbc369208dfe77bf273add91d5300000000000000000000000004fd6913d6c32d8c216e153a43c04b1857a7793d000000000000000000000000885f707efa18d2cb12f05a3a8eba6b4b26c8c1d40000000000000000000000007160a322fea44945a6ef9adfd65c322258df3c5e000000000000000000000000fe33b439ec53748c87dcedacb83f05add50147440000000000000000000000004d0edd347fb1fa21589c1e109b3474924be87636000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba3000000000000000000000000c29d6995ab3b0df4650ad643adeac55e7acbb566","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}